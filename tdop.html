<HTML><HEAD><META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
    <TITLE>Simplified JavaScript parsing and interpretation</TITLE>
    <STYLE>
th {background-color: thistle; border: black solid 1px; text-align: left;
    padding-left: 10px; padding-right: 10px; vertical-align: top;}
td {background-color: white; border: black solid 1pt; padding-left: 10px;
    padding-right: 10px; vertical-align: top;}
table {width: 90%; border: 0px; cellpadding: 0px;}
    </STYLE>
</HEAD><BODY bgcolor="linen">
<H1>Simplified JavaScript parsing and interpretation</H1>

<p>C. Scott Ananian, based on a grammar by Douglas Crockford</p>

<H2>Demonstration</H2>

<p>This demo is heavily modified from
<A href="http://www.crockford.com/">Douglas Crockford</A>'s
original <A href="http://javascript.crockford.com/tdop/tdop.html">Top
Down Operator Precedence</A> JavaScript grammar
<A href="http://javascript.crockford.com/tdop/index.html">demo</a>,
which is described in chapter 9 of the book <A href="http://www.amazon.com/exec/obidos/ASIN/0596510047/wrrrldwideweb">Beautiful
  Code</A>.</p>

<p>This page contains a tokenizer, parser, bytecode compiler, and bytecode
interpreter for Simplified JavaScript, all of which are written in
Simplified JavaScript.  This page compiles all these pieces to
bytecode and then runs them in the interpreter.  The interpreted
version of the bytecode compiler is given a simple addition statement
to compile.</p>

<P>This page loads five main JavaScript files:</P>
<TABLE border="0" align="center">
  <TBODY><TR>
    <TD valign="top"><A href="./tokenize.js">tokenize.js</A></TD>
    <TD>This file installs the <code>tokenize</code> function which produces an array of simple tokens from a string.</TD>
  </TR>
  <TR>
    <TD valign="top"><A href="./parse.js">parse.js</A></TD>
    <TD>This file installs the <CODE>make_parse</CODE> function which produces
      the parse function. The indirection was done so that we could conveniently
      recover the source of the function.</TD>
  </TR>
  <TR>
    <TD valign="top"><A href="./bytecode_table.js">bytecode_table.js</A></TD>
    <TD>This file installs the <CODE>make_bytecode_table</CODE> function which
      wraps the short list of bytecode instructions used by the compiler and
      interpreter.</TD>
  </TR>
  <TR>
    <TD valign="top"><A href="./bcompile.js">bcompile.js</A></TD>
    <TD>This file installs the <CODE>make_bcompile</CODE> function
      which produces the <code>bcompile</code> function.  This
      compiles a parse tree into a list of bytecode-compiled functions.</TD>
  </TR>
  <TR>
    <TD valign="top"><A href="./binterp.js">binterp.js</A></TD>
    <TD>This file installs the <CODE>make_binterp</CODE> function
      which produces the bytecode interpreter.  It piggybacks on the
      meta-level's object system, but otherwise tries hard not to
      let meta-level definitions leak into the interpreted state.
      All primitive objects and library functions are reimplemented
      inside the interpreter, for example.</TD>
  </TR>
</TBODY></TABLE>
<P>The text that follows is the parse tree that the parser generated by
  parsing itself. </P>
<NOSCRIPT></NOSCRIPT>
<SCRIPT src="./global.js"></SCRIPT>
<SCRIPT src="./tokenize.js"></SCRIPT>
<SCRIPT src="./parse.js"></SCRIPT>
<SCRIPT src="./json2.js"></SCRIPT>
<SCRIPT src="./jcompile.js"></SCRIPT>
<SCRIPT src="./render.js"></SCRIPT>
<SCRIPT src="./bytecode_table.js"></SCRIPT>
<SCRIPT src="./bcompile.js"></SCRIPT>
<SCRIPT src="./binterp.js"></SCRIPT>
<SCRIPT src="./tests.js"></SCRIPT>

<pre id="errors"></pre>
<pre id="isource"></pre>
<pre id="expected-result"></pre>
<pre id="result"></pre>
<div id="source"></div>
<pre id="parse-tree"></pre>
<pre id="jcompile"></pre>
<pre id="raw-bytecode"></pre>
<div id="bytecode"></div>

<PRE id="output"><SCRIPT>
/*jslint evil: true */

/*members create, error, message, name, prototype, stringify, toSource,
    toString, write
*/

/*global JSON, make_parse, parse, source, tree */

// Transform a token object into an exception object and throw it.
// (this conflicts with jQuery, so we're going to keep it out of global.js)
Object.prototype.error = function (message, t) {
    t = t || this;
    t.name = "SyntaxError";
    t.message = message;
    throw t;
};

var CATCH_ERRORS = true;
var SHOW_SOURCE = true;
var PRINT_TREE = false;
var PRINT_JCOMPILE = false;
var PRINT_RAW_BYTECODE = false;

function fill(elem_id, h1, contents, no_escape) {
  if (!no_escape) contents = html_escape(contents);
  elem = document.getElementById(elem_id);
  elem.innerHTML = "<h1>" + h1 + "</h1>\n" + contents;
}

function do_it() {
    parse = make_parse(tokenize);

// We are going to make the compiler/interpreter compile itself.
    var self_test = function (source) {
       var result;
       var parse = make_parse(tokenize);
       var bc_table = make_bytecode_table();
       var bcompile = make_bcompile(bc_table);
       source = source || '{ return 1+2; }';
       //result = tokenize(source, '=<>!+-*&|/%^', '=<>&|');
       var tree = parse(source, "isFinite parseInt Boolean String Function Math console arguments");
       //result = tree;
       var bc = bcompile(tree);
       result = bc.decompile(0);
       //console.log(result);
       return result;
    }

    sources = make_tests(tokenize, make_parse, make_jcompile, make_render,
                        make_bytecode_table, make_bcompile, make_binterp,
                        make_binterp().library_init,
                        self_test);

    // combine sources
    isource = '{ return 2+3; }'; // input to interpreted version of compiler
    source = sources[0].replace(/module/, "tokenize") + "\n" +
             sources[1].replace(/module/, "make_parse") + "\n" +
             sources[4].replace(/module/, "make_bytecode_table") + "\n" +
             sources[5].replace(/module/, "make_bcompile") + "\n" +
             sources[6].replace(/module/, "make_binterp") + "\n" +
             sources[7].replace(/module/, "library_init") + "\n" +
             sources[8].replace(/module/, "self_test") + "\n" +
             "{ library_init(); return self_test(arguments[0]); }\n";

    if (0) {
    // HACK to run specific test cases
    test_case = sources[22].replace(/module/, "self_test");
    eval(test_case); // defines the 'self_test' method
    source = sources[7].replace(/module/, "library_init") + "\n" +
             test_case + "\n" +
             "{ library_init(); return self_test(); }\n";
    // END HACK
    }

    if (1) {
       // for use comparing the output of the interpreter with the
       // output of the javascript code run directly.
       eresult = self_test(isource);
       if (typeof(eresult) != "string") eresult = ""+JSON.stringify(eresult);
       fill('expected-result', 'Expected result', eresult);
    }

    if (SHOW_SOURCE) {
       sl = source.split(/\n/);
       ci = 0;
       o = "<pre>";
       for (j=0; j < sl.length; j++) {
          o += ci+": "+html_escape(sl[j])+"\n";
          ci += sl[j].length + 1;
       }
       o += "</pre>";
       fill('source', 'Interpreted source', o, 1/*no escape*/);
   }

   top_level_defs = "isFinite parseInt Boolean String Function Math " +
                     "make_tests console arguments document html_escape";
    tree = parse(source, top_level_defs);
    if (tree) {
        /* Raw compiled tree */
        if (PRINT_TREE) {
           fill('parse-tree', 'Parse tree',
            JSON.stringify(tree, ['key', 'name', 'message',
            'value', 'arity', 'first', 'second', 'third', 'fourth'], 4));
        }

        /* Pretty-printed to eval'able javascript */
        if (PRINT_JCOMPILE) {
           jcompile = make_jcompile();
           fill('jcompile', 'Recompiled to JavaScript', jcompile(tree));
        }

        /* Bytecode compiled (raw) */
        bc_table = make_bytecode_table();
        bcompile = make_bcompile(bc_table);
        bc = bcompile(tree);
        if (PRINT_RAW_BYTECODE) {
            fill('raw-bytecode', 'Raw Bytecode File Contents',
                 JSON.stringify(bc, ['functions', 'literals', 'id', 'nargs',
                                     'bytecode', 'label'], 4));
        }

        /* Pretty-printed bytecode */
        b = "<p>Index: ";
        for (i=0; i<bc.functions.length; i++) {
          var f = bc.functions[i];
          b+= "<a href='#bc-"+i+"'>";
          b+= html_escape((f.name) ? f.name : ("<#"+i+">"));
          b+= "</a> ";
        }
        b += "</p>";
        for (i=0; i<bc.functions.length; i++) {
          var f = bc.functions[i];
          b += "<h2><a id='bc-"+i+"'>Function #"+f.id;
          if (f.name) b += " "+html_escape(f.name);
          b += "</a>";
          b += " ("+f.nargs+" args; max stack depth="+f.max_stack+")</h2>\n";
          b += "<pre>"+html_escape(bc.decompile(f.id))+"</pre>";
        }
        fill('bytecode', 'Compiled Bytecode', b, 1/*no escape*/);

        /* Interpreter test! */
        m = make_binterp(bc_table);
        frame = m.make_top_level_frame.call(/*this: */{/*this*/} ,
                                            /* args:*/ isource);
        result = m.binterp(bc, 0, frame);
        fill('isource', 'Input to interpreted compiler', isource);
        if (typeof(result) != "string") result = ""+JSON.stringify(result);
        fill('result', 'Result from interpreter', result);
   }
}

if (!CATCH_ERRORS) {
    do_it();
} else {
    try {
        do_it();
    } catch (e) {
        fill('errors', 'Error!',
             JSON.stringify(e, ['name', 'message', 'from', 'to',
                                          'key', 'value', 'arity', 'first',
                                          'second', 'third', 'fourth'], 4));
    }
}


</SCRIPT>
</PRE>


</BODY></HTML>
