
<!-- saved from url=(0047)http://javascript.crockford.com/tdop/index.html -->
<HTML><HEAD><META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
    <TITLE>Top Down Operator Precedence</TITLE>
    <STYLE>
th {background-color: thistle; border: black solid 1px; text-align: left;
    padding-left: 10px; padding-right: 10px; vertical-align: top;}
td {background-color: white; border: black solid 1pt; padding-left: 10px;
    padding-right: 10px; vertical-align: top;}
table {width: 90%; border: 0px; cellpadding: 0px;}
    </STYLE>
</HEAD><BODY bgcolor="linen">
<H1>Top Down Operator Precedence</H1>

<P><A href="http://www.crockford.com/">Douglas Crockford</A></P>

<P>2007-08-05</P>

<H2>Demonstration</H2>
<P>This is the companion file to my paper on <A href="http://javascript.crockford.com/tdop/tdop.html">Vaughan
  Pratt's Top Down Operator Precedence</A>. The paper presents a parser
  for Simplified JavaScript that is written in Simplified Javascript. It
  is chapter 9 of <A href="http://www.amazon.com/exec/obidos/ASIN/0596510047/wrrrldwideweb">Beautiful
  Code</A>. This page loads that parser and runs the parser on itself. </P>
<P>This page loads three JavaScript files:</P>
<TABLE border="0" align="center">
  <TBODY><TR>
    <TD valign="top"><A href="./tokens.js">tokens.js</A></TD>
    <TD>This file installs the <CODE>String.prototype.tokens</CODE> method. It
      produces an array of simple tokens from a string.</TD>
  </TR>
  <TR>
    <TD valign="top"><A href="./parse.js">parse.js</A></TD>
    <TD>This file installs the <CODE>make_parse</CODE> function which produces
      the parse function. The indirection was done so that we could conveniently
      recover the source of the function.</TD>
  </TR>
  <TR>
    <TD valign="top"><A href="http://json.org/json2.js">json2.js</A></TD>
    <TD>This file installs the <CODE>JSON.stringify</CODE> method.
      It is used to display the parse tree.</TD>
  </TR>
</TBODY></TABLE>
<P>The text that follows is the parse tree that the parser generated by
  parsing itself. </P>
<NOSCRIPT></NOSCRIPT>
<SCRIPT src="./global.js"></SCRIPT>
<SCRIPT src="./tokenize.js"></SCRIPT>
<SCRIPT src="./parse.js"></SCRIPT>
<SCRIPT src="./json2.js"></SCRIPT>
<SCRIPT src="./jcompile.js"></SCRIPT>
<SCRIPT src="./render.js"></SCRIPT>
<SCRIPT src="./bytecode_table.js"></SCRIPT>
<SCRIPT src="./bcompile.js"></SCRIPT>
<SCRIPT src="./binterp.js"></SCRIPT>
<SCRIPT src="./tests.js"></SCRIPT>
<PRE><SCRIPT>
/*jslint evil: true */

/*members create, error, message, name, prototype, stringify, toSource,
    toString, write
*/

/*global JSON, make_parse, parse, source, tree */

// Transform a token object into an exception object and throw it.
// (this conflicts with jQuery, so we're going to keep it out of global.js)
Object.prototype.error = function (message, t) {
    t = t || this;
    t.name = "SyntaxError";
    t.message = message;
    throw t;
};

var CATCH_SYNTAX_ERRORS = false;
var SHOW_SOURCE = true;
var PRINT_TREE = false;
var PRINT_JCOMPILE = false;
var PRINT_RAW_BYTECODE = false;

function do_it() {
    parse = make_parse(tokenize);

// We are going to make the parse function parse itself.
    var self_test = function (source) {
       var result;
       var parse = make_parse(tokenize);
       var bc_table = make_bytecode_table();
       var bcompile = make_bcompile(bc_table);
       source = source || '{ return 1+2; }';
       //result = tokenize(source, '=<>!+-*&|/%^', '=<>&|');
       var tree = parse(source, "isFinite parseInt String");
       //result = tree;
       var bc = bcompile(tree);
       result = bc.decompile(0);
       console.log(result);
       return result;
    }
    //document.write("<h1>TEST: "+self_test('{return 1+2;}')+"</h1>");

    sources = make_tests(tokenize, make_parse, make_jcompile, make_render,
                        make_bytecode_table, make_bcompile, make_binterp,
                        make_binterp().library_init,
                        self_test);

    // combine sources
    source = sources[0].replace(/module/, "tokenize") + "\n" +
             sources[1].replace(/module/, "make_parse") + "\n" +
             sources[4].replace(/module/, "make_bytecode_table") + "\n" +
             sources[5].replace(/module/, "make_bcompile") + "\n" +
             sources[7].replace(/module/, "library_init") + "\n" +
             sources[8].replace(/module/, "self_test") + "\n" +
             "{ library_init(); return self_test(arguments[0]); }\n";

    if (0) {
    // HACK to show scoping bug.
    eval(sources[22].replace(/module/, "my_test")); my_test();
    source = sources[7].replace(/module/, "library_init") + "\n" +
             sources[22].replace(/module/, "test") + "\n" +
             "{ library_init(); return test(); }\n";
    }
    // END HACK

    tree = parse(source, "isFinite parseInt Boolean String make_tests console arguments");
    if (tree) {
        /* Raw compiled tree */
        if (PRINT_TREE) {
        document.write(html_escape(
            JSON.stringify(tree, ['key', 'name', 'message',
            'value', 'arity', 'first', 'second', 'third', 'fourth'], 4)));
        document.write("\n\n");
        }

        /* Pretty-printed to eval'able javascript */
        jcompile = make_jcompile();
        if (PRINT_JCOMPILE) {
        document.write(html_escape(jcompile(tree)));
        }

        /* Bytecode compiled (raw) */
        bc_table = make_bytecode_table();
        bcompile = make_bcompile(bc_table);
        bc = bcompile(tree);
        if (PRINT_RAW_BYTECODE) {
        document.write(html_escape(
            JSON.stringify(bc, ['functions', 'literals', 'id', 'nargs',
                                  'bytecode'], 4)));
        document.write("\n\n");
        }

        /* Pretty-printed bytecode */
        document.write("<h1><a id='bytecode'>Bytecode</a></h1>");
        for (i=0; i<bc.functions.length; i++) {
          var f = bc.functions[i];
          document.write("<h2>Function #"+f.id);
          if (f.name) {
            document.write(" "+f.name);
          }
          document.write(" ("+f.nargs+" args; max stack depth="+f.max_stack+")</h2>");
          document.write(html_escape(bc.decompile(f.id)));
        }

        /* Interpreter test! */
        m = make_binterp(bc_table);
        frame = m.make_top_level_frame.call(/*this: */{/*this*/} ,
                                            /* args:*/ '{ return 2+3; }');
        result = m.binterp(bc, 0, frame);
        document.write("<h2>Evaluating function #1 yields: ");
        document.write("<a id='result'>" + result + "</a></h2>\n");
   }
}

if (!CATCH_SYNTAX_ERRORS) {
    do_it();
} else {
    try {
        do_it();
    } catch (e) {
        document.write(JSON.stringify(e, ['name', 'message', 'from', 'to',
                                          'key', 'value', 'arity', 'first',
                                          'second', 'third', 'fourth'], 4));
        document.write("\n");
    }
}

if (SHOW_SOURCE) {
    document.write("<h1><a id='source'>Source</a></h1>");
    sl = source.split(/\n/);
    ci = 0;
    for (j=0; j < sl.length; j++) {
       document.write(ci+": "+sl[j]+"\n");
       ci += sl[j].length + 1;
    }
}

</SCRIPT>
</PRE>


</BODY></HTML>
