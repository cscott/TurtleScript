
<!-- saved from url=(0047)http://javascript.crockford.com/tdop/index.html -->
<HTML><HEAD><META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
    <TITLE>Top Down Operator Precedence</TITLE>
    <STYLE>
th {background-color: thistle; border: black solid 1px; text-align: left;
    padding-left: 10px; padding-right: 10px; vertical-align: top;}
td {background-color: white; border: black solid 1pt; padding-left: 10px;
    padding-right: 10px; vertical-align: top;}
table {width: 90%; border: 0px; cellpadding: 0px;}
    </STYLE>
</HEAD><BODY bgcolor="linen">
<H1>Top Down Operator Precedence</H1>

<P><A href="http://www.crockford.com/">Douglas Crockford</A></P>

<P>2007-08-05</P>

<H2>Demonstration</H2>
<P>This is the companion file to my paper on <A href="http://javascript.crockford.com/tdop/tdop.html">Vaughan
  Pratt's Top Down Operator Precedence</A>. The paper presents a parser
  for Simplified JavaScript that is written in Simplified Javascript. It
  is chapter 9 of <A href="http://www.amazon.com/exec/obidos/ASIN/0596510047/wrrrldwideweb">Beautiful
  Code</A>. This page loads that parser and runs the parser on itself. </P>
<P>This page loads three JavaScript files:</P>
<TABLE border="0" align="center">
  <TBODY><TR>
    <TD valign="top"><A href="./tokens.js">tokens.js</A></TD>
    <TD>This file installs the <CODE>String.prototype.tokens</CODE> method. It
      produces an array of simple tokens from a string.</TD>
  </TR>
  <TR>
    <TD valign="top"><A href="./parse.js">parse.js</A></TD>
    <TD>This file installs the <CODE>make_parse</CODE> function which produces
      the parse function. The indirection was done so that we could conveniently
      recover the source of the function.</TD>
  </TR>
  <TR>
    <TD valign="top"><A href="http://json.org/json2.js">json2.js</A></TD>
    <TD>This file installs the <CODE>JSON.stringify</CODE> method.
      It is used to display the parse tree.</TD>
  </TR>
</TBODY></TABLE>
<P>The text that follows is the parse tree that the parser generated by
  parsing itself. </P>
<NOSCRIPT></NOSCRIPT>
<SCRIPT src="./global.js"></SCRIPT>
<SCRIPT src="./tokenize.js"></SCRIPT>
<SCRIPT src="./parse.js"></SCRIPT>
<SCRIPT src="./json2.js"></SCRIPT>
<SCRIPT src="./compile.js"></SCRIPT>
<SCRIPT src="./bytecode_table.js"></SCRIPT>
<SCRIPT src="./bytecode.js"></SCRIPT>
<SCRIPT src="./render.js"></SCRIPT>
<SCRIPT src="./tests.js"></SCRIPT>
<PRE><SCRIPT>
/*jslint evil: true */

/*members create, error, message, name, prototype, stringify, toSource,
    toString, write
*/

/*global JSON, make_parse, parse, source, tree */

// Transform a token object into an exception object and throw it.
// (this conflicts with jQuery, so we're going to keep it out of global.js)
Object.prototype.error = function (message, t) {
    t = t || this;
    t.name = "SyntaxError";
    t.message = message;
    throw t;
};

var CATCH_SYNTAX_ERRORS = false;
var SHOW_SOURCE = true;

function do_it() {
    parse = make_parse(tokenize);

// We are going to make the parse function parse itself.

    source = make_tests(tokenize, make_parse, make_compile, make_render,
                        make_bcompile)[0];
    tree = parse(source, "isFinite parseInt String make_tests");
    if (tree) {
        /* Raw compiled tree */
        document.write(html_escape(
            JSON.stringify(tree, ['key', 'name', 'message',
            'value', 'arity', 'first', 'second', 'third', 'fourth'], 4)));
        document.write("\n\n");

        /* Pretty-printed to eval'able javascript */
        compile = make_compile();
        document.write(html_escape(compile(tree)));

        /* Bytecode compiled (raw) */
        bc_table = make_bytecode_table();
        bcompile = make_bcompile(bc_table);
        bc = bcompile(tree);
        document.write(html_escape(
            JSON.stringify(bc, ['functions', 'strings', 'id', 'nargs',
                                  'bytecode'], 4)));
        document.write("\n\n");

        /* Pretty-printed bytecode */
        for (i=0; i<bc.functions.length; i++) {
          var f = bc.functions[i];
          document.write("<h2>Function #"+f.id+" ("+f.nargs+" args; max stack depth="+f.max_stack+")</h2>");
          document.write(html_escape(bc.decompile(f.id)));
        }
   }
}

if (!CATCH_SYNTAX_ERRORS) {
    do_it();
} else {
    try {
        do_it();
    } catch (e) {
        document.write(JSON.stringify(e, ['name', 'message', 'from', 'to',
                                          'key', 'value', 'arity', 'first',
                                          'second', 'third', 'fourth'], 4));
        document.write("\n");
    }
}

if (SHOW_SOURCE) {
    sl = source.split(/\n/);
    ci = 0;
    for (j=0; j < sl.length; j++) {
       document.write(ci+": "+sl[j]+"\n");
       ci += sl[j].length + 1;
    }
}

</SCRIPT>
</PRE>


</BODY></HTML>
