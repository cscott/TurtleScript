<!DOCTYPE html>

<html>
<head>
  <title>asm-llvm.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="asm-llvm.html">
                asm-llvm.js
              </a>
            
              
              <a class="source" href="bcompile.html">
                bcompile.js
              </a>
            
              
              <a class="source" href="binterp.html">
                binterp.js
              </a>
            
              
              <a class="source" href="browsercanvas.html">
                browsercanvas.js
              </a>
            
              
              <a class="source" href="bytecode-table.html">
                bytecode-table.js
              </a>
            
              
              <a class="source" href="canvastest.html">
                canvastest.js
              </a>
            
              
              <a class="source" href="ccanvas.html">
                ccanvas.js
              </a>
            
              
              <a class="source" href="crender-styles.html">
                crender-styles.js
              </a>
            
              
              <a class="source" href="crender.html">
                crender.js
              </a>
            
              
              <a class="source" href="ctiles.html">
                ctiles.js
              </a>
            
              
              <a class="source" href="events.html">
                events.js
              </a>
            
              
              <a class="source" href="eventtests.html">
                eventtests.js
              </a>
            
              
              <a class="source" href="extensions.html">
                extensions.js
              </a>
            
              
              <a class="source" href="global-es5.html">
                global-es5.js
              </a>
            
              
              <a class="source" href="global.html">
                global.js
              </a>
            
              
              <a class="source" href="html-escape.html">
                html-escape.js
              </a>
            
              
              <a class="source" href="jcompile.html">
                jcompile.js
              </a>
            
              
              <a class="source" href="json2.html">
                json2.js
              </a>
            
              
              <a class="source" href="nodemain.html">
                nodemain.js
              </a>
            
              
              <a class="source" href="parse.html">
                parse.js
              </a>
            
              
              <a class="source" href="render.html">
                render.js
              </a>
            
              
              <a class="source" href="render2.html">
                render2.js
              </a>
            
              
              <a class="source" href="require.html">
                require.js
              </a>
            
              
              <a class="source" href="stdlib.html">
                stdlib.js
              </a>
            
              
              <a class="source" href="str-escape.html">
                str-escape.js
              </a>
            
              
              <a class="source" href="tdop.html">
                tdop.js
              </a>
            
              
              <a class="source" href="tests.html">
                tests.js
              </a>
            
              
              <a class="source" href="tiles.html">
                tiles.js
              </a>
            
              
              <a class="source" href="tokenize.html">
                tokenize.js
              </a>
            
              
              <a class="source" href="top-level.html">
                top-level.js
              </a>
            
              
              <a class="source" href="ts.html">
                ts.js
              </a>
            
              
              <a class="source" href="write-rust-bytecode.html">
                write-rust-bytecode.js
              </a>
            
              
              <a class="source" href="write-rust-ops.html">
                write-rust-ops.js
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>asm-llvm.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <p><code>asm-llvm.js</code> is a parser for <a href="http://asmjs.org">asm.js</a> written
in <a href="http://github.com/cscott/turtlescript">TurtleScript</a>, a
syntactically-simplified JavaScript.  It is written by
C. Scott Ananian and released under an MIT license.</p>
<p>The parser is based on the tiny, fast
<a href="http://marijnhaverbeke.nl/acorn/">acorn parser</a>
of Marijn Haverbeke, which in turn borrowed from
<a href="http://esprima.org">Esprima</a> by Ariya Hidayat.</p>
<p><code>asm-llvm.js</code> attempts to do parsing, type-checking, and compilation to
LLVM bytecode in a single pass.  Mozilla
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=854061">bug 854061</a>
describes a similar attempt in the Firefox/SpiderMonkey codebase;
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=864600">bug 864600</a>
describes recent changes to the <code>asm.js</code> spec to allow single-pass
compilation.</p>
<p>Copyright (c) 2013 C. Scott Ananian</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>define([], <span class="function"><span class="keyword">function</span> <span class="title">asm_llvm</span><span class="params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>The module object.
(This is used by <code>tests.js</code> to recreate the module source.)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> asm_llvm_module = {
        __module_name__: <span class="string">"asm-llvm"</span>,
        __module_init__: asm_llvm,
        __module_deps__: []
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <h2><code>asm.js</code> type system</h2>
<p>Set up the <a href="http://asmjs.org/spec/latest/#types">type system of asm.js</a>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> Type = {
        _id: <span class="number">0</span>,
        _derived: {},
        supertypes: []
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>We do hash-consing of <code>Type</code> objects so that we have a singleton object
representing every unique type, no matter how it was derived.
The basis is <code>Type.derive()</code>, which creates one <code>Type</code> object from
another.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Type.derive = (<span class="keyword">function</span>() {
        <span class="keyword">var</span> id = <span class="number">1</span>;
        <span class="keyword">return</span> <span class="keyword">function</span>(spec, properties) {
            <span class="keyword">var</span> ty = <span class="keyword">this</span>._derived[spec];
            <span class="keyword">if</span> (ty) { <span class="keyword">return</span> ty; }
            ty = <span class="keyword">this</span>._derived[spec] = Object.create(<span class="keyword">this</span>);
            ty._id = id; id += <span class="number">1</span>;
            ty._derived = [];</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>Default to a simple toString method, good for value types.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            properties = properties || {};
            <span class="keyword">if</span> (!properties.hasOwnProperty(<span class="string">'toString'</span>)) {
                properties.toString = <span class="keyword">function</span>() { <span class="keyword">return</span> spec; };
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>Allow the caller to override arbitrary properties.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            Object.keys(properties || {}).forEach(<span class="keyword">function</span>(k) {
                <span class="keyword">if</span> (properties[k] !== <span class="literal">undefined</span>) {
                    ty[k] = properties[k];
                }
            });
            <span class="keyword">return</span> ty;
        };
    })();</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>Compute the subtype relation between types, based on the
<code>supertypes</code> field.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Type.isSubtypeOf = <span class="keyword">function</span>(ty) {
        <span class="keyword">if</span> (<span class="keyword">this</span> === ty) { <span class="keyword">return</span> <span class="literal">true</span>; } <span class="comment">// common case</span>
        <span class="keyword">return</span> <span class="keyword">this</span>.supertypes.some(<span class="keyword">function</span>(t) {
            <span class="keyword">return</span> t.isSubtypeOf(ty);
        });
    };

    <span class="keyword">var</span> Types = Object.create(<span class="literal">null</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>The top-level internal types (which do not escape, and are not
a supertype of any other type) are &quot;doublish&quot; and &quot;intish&quot;.</p>
<p>Intish represents the result of a JavaScript integer operation
that must be coerced back to an integer with an explicit
coercion.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Types.Intish = Type.derive(<span class="string">"intish"</span>, { value: <span class="literal">true</span> });</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>Similar to intish, the doublish type represents operations that
are expected to produce a double but may produce additional
junk that must be coerced back to a number.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Types.Doublish = Type.derive(<span class="string">"doublish"</span>, { value: <span class="literal">true</span> });</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>Void is the type of functions that are not supposed to return any
useful value.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Types.Void = Type.derive(<span class="string">"void"</span>, { value: <span class="literal">true</span> });</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>Make void a subtype of intish, since in practice JS functions return
&#39;undefined&#39;, which can be cast to a double or int.  The choice of
intish makes forward declarations easier.
See discussion in mozilla
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=854061">bug 854061</a>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Types.Void.supertypes = [Types.Intish];</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>The other internal (non-escaping) types are &#39;unknown&#39; and &#39;int&#39;.
The unknown type represents a value returned from an FFI call.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Types.Unknown = Type.derive(<span class="string">"unknown"</span>, {
        value: <span class="literal">true</span>,
        supertypes: [Types.Doublish, Types.Intish]
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>The int type is the type of 32-bit integers where the
signedness is not known.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Types.Int = Type.derive(<span class="string">"int"</span>, {
        value: <span class="literal">true</span>,
        supertypes: [Types.Intish]
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>The rest of the value types can escape into non-asm.js code.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Types.Extern = Type.derive(<span class="string">"extern"</span>, { value: <span class="literal">true</span> });
    Types.Double = Type.derive(<span class="string">"double"</span>, {
        value: <span class="literal">true</span>,
        supertypes: [Types.Doublish, Types.Extern]
    });
    Types.Signed = Type.derive(<span class="string">"signed"</span>, {
        value: <span class="literal">true</span>,
        supertypes: [Types.Extern, Types.Int],
        min: -<span class="number">2147483648</span>, <span class="comment">// -2^31</span>
        max: -<span class="number">1</span> <span class="comment">// range excludes 0</span>
    });
    Types.Unsigned = Type.derive(<span class="string">"unsigned"</span>, {
        value: <span class="literal">true</span>,
        supertypes: [Types.Extern, Types.Int],
        min: <span class="number">2147483648</span>, <span class="comment">// 2^31</span>
        max: <span class="number">4294967295</span>  <span class="comment">// (2^32)-1</span>
    });
    Types.Fixnum = Type.derive(<span class="string">"fixnum"</span>, {
        value: <span class="literal">true</span>,
        supertypes: [Types.Signed, Types.Unsigned],
        min: <span class="number">0</span>,
        max: <span class="number">2147483647</span> <span class="comment">// (2^31)-1</span>
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>Global (non-value) types.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Types.Function = Type.derive(<span class="string">"Function"</span>);
    Types.ArrayBufferView = Type.derive(<span class="string">"ArrayBufferView"</span>);
    [<span class="string">'Int'</span>, <span class="string">'Uint'</span>, <span class="string">'Float'</span>].forEach(<span class="keyword">function</span>(elementType) {
        <span class="keyword">var</span> view = Types.ArrayBufferView.derive(elementType+<span class="string">'Array'</span>);
        Types[elementType+<span class="string">'Array'</span>] = <span class="keyword">function</span>(n) {
            <span class="keyword">return</span> view.derive(n, {
                arrayBufferView: <span class="literal">true</span>,
                base: (elementType===<span class="string">'Float'</span>) ? Types.Doublish : Types.Intish,
                bytes: Math.floor(n/<span class="number">8</span>),
                toString: <span class="keyword">function</span>() { <span class="keyword">return</span> elementType + n + <span class="string">'Array'</span>; }
            });
        };
    });
    Types.Arrow = (<span class="keyword">function</span>() {
        <span class="keyword">var</span> arrowToString = <span class="keyword">function</span>() {
            <span class="keyword">var</span> params = Array.prototype.map.call(<span class="keyword">this</span>, <span class="keyword">function</span>(pt) {
                <span class="keyword">return</span> pt.toString();
            });
            <span class="keyword">return</span> <span class="string">'('</span> + params.join(<span class="string">','</span>) + <span class="string">')-&gt;'</span> + <span class="keyword">this</span>.retType.toString();
        };
        <span class="keyword">var</span> arrowApply = <span class="keyword">function</span>(args) {
            <span class="keyword">return</span> Array.prototype.every.call(<span class="keyword">this</span>, <span class="keyword">function</span>(pt, i) {
                <span class="keyword">return</span> args[i].isSubtypeOf(pt);
            }) ? <span class="keyword">this</span>.retType : <span class="literal">null</span>;
        };
        <span class="keyword">return</span> <span class="keyword">function</span>(argtypes, retType) {</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>We derive a function type starting from the return type, and
proceeding to the argument types in order.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">var</span> result = retType.derive(<span class="string">'()-&gt;'</span>, {
                arrow: <span class="literal">true</span>,
                retType: retType,
                length: <span class="number">0</span>, <span class="comment">// number of arguments</span>
                apply: arrowApply,
                toString: arrowToString
            });
            argtypes.forEach(<span class="keyword">function</span>(ty, idx) {
                <span class="keyword">var</span> param = { length: (idx+<span class="number">1</span>), toString: <span class="literal">undefined</span> };
                param[idx] = ty;
                result = result.derive(ty._id, param);
            });
            <span class="keyword">return</span> result;
        };
    })();
    Types.FunctionTypes = (<span class="keyword">function</span>() {
        <span class="keyword">var</span> functionTypesToString = <span class="keyword">function</span>() {
            <span class="keyword">var</span> types = Array.prototype.map.call(<span class="keyword">this</span>, <span class="keyword">function</span>(f) {
                <span class="keyword">return</span> f.toString();
            });
            <span class="keyword">return</span> <span class="string">'['</span> + types.join(<span class="string">' ^ '</span>) + <span class="string">']'</span>;
        };
        <span class="keyword">var</span> functionTypesApply = <span class="keyword">function</span>(args) {
            <span class="keyword">var</span> i = <span class="number">0</span>;
            <span class="keyword">while</span> (i &lt; <span class="keyword">this</span>.length) {
                <span class="keyword">var</span> ty = <span class="keyword">this</span>[i].apply(args);
                <span class="keyword">if</span> (ty!==<span class="literal">null</span>) { <span class="keyword">return</span> ty; }
                i += <span class="number">1</span>;
            }
            <span class="keyword">return</span> <span class="literal">null</span>;
        };
        <span class="keyword">return</span> <span class="keyword">function</span>(functiontypes) {</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>Sort the function types by id, to make a canonical ordering,
then derive the <code>FunctionTypes</code> type.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            functiontypes.sort(<span class="keyword">function</span>(a,b) { <span class="keyword">return</span> a._id - b._id; });
            <span class="keyword">var</span> result = Type.derive(<span class="string">'FunctionTypes'</span>, {
                functiontypes: <span class="literal">true</span>,
                length: <span class="number">0</span>, <span class="comment">// number of arrow types</span>
                <span class="comment">/* methods */</span>
                apply: functionTypesApply,
                toString: functionTypesToString
            });
            functiontypes.forEach(<span class="keyword">function</span>(ty, idx) {
                <span class="keyword">var</span> param = { length: (idx+<span class="number">1</span>), toString: <span class="literal">undefined</span> };
                param[idx] = ty;
                result = result.derive(ty._id, param);
            });
            <span class="keyword">return</span> result;
        };
    })();
    Types.Table = (<span class="keyword">function</span>() {
        <span class="keyword">var</span> tableToString = <span class="keyword">function</span>() {
            <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.base.toString() + <span class="string">')['</span> + <span class="keyword">this</span>.size + <span class="string">']'</span>;
        };
        <span class="keyword">return</span> <span class="keyword">function</span>(functype, size) {
            <span class="keyword">var</span> t = functype.derive(<span class="string">'Table'</span>, { table: <span class="literal">true</span>, base: functype });
            <span class="keyword">return</span> t.derive(size, { size: size, toString: tableToString });
        };
    })();</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>Special type used to mark the module name, stdlib, foreign, and heap
identifiers.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Types.Module = Type.derive(<span class="string">"Module"</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>Special type used to mark possible forward references.
Note that a value of ForwardReference type should always be actually
of type <code>Arrow</code> (local function) or <code>Table</code> (global function table).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Types.ForwardReference = Type.derive(<span class="string">"ForwardReference"</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>Utility functions.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> ceilLog2 = <span class="keyword">function</span>(x) {
        <span class="keyword">var</span> r = <span class="number">0</span>; x-=<span class="number">1</span>;
        <span class="keyword">while</span> (x!==<span class="number">0</span>) { x = Math.floor(x/<span class="number">2</span>); r+=<span class="number">1</span>; } <span class="comment">// XXX want shift!</span>
        <span class="keyword">return</span> r;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>Only powerOf2 sizes are legit for function tables.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> powerOf2 = <span class="keyword">function</span>(x) {
        <span class="comment">/* return (x &amp; (x - 1)) === 0; // how cool kids do it */</span>
        <span class="keyword">return</span> x === Math.pow(<span class="number">2</span>, ceilLog2(x)); <span class="comment">// TurtleScript needs bitwise ops</span>
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>Quick self-test for the type system.  Ensure that identical types
created at two different times still compare ===.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> test_types = <span class="keyword">function</span>() {
        <span class="keyword">var</span> sqrt1 = Types.FunctionTypes(
            [Types.Arrow([Types.Double], Types.Double)]);
        <span class="keyword">var</span> sqrt2 = Types.FunctionTypes(
            [Types.Arrow([Types.Double], Types.Double)]);
        console.assert(sqrt1 === sqrt2);
        console.assert(sqrt1.functiontypes);
        console.assert(sqrt1.length===<span class="number">1</span>);
        console.assert(sqrt1[<span class="number">0</span>].arrow);
        console.assert(sqrt1[<span class="number">0</span>].length===<span class="number">1</span>);
        console.assert(sqrt1[<span class="number">0</span>][<span class="number">0</span>]===Types.Double);
        console.assert(Types.Arrow([],Types.Double).toString() === <span class="string">'()-&gt;double'</span>);
        console.assert(sqrt1.toString() === <span class="string">'[(double)-&gt;double]'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>Test function table types.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> t1 = Types.Table(sqrt1[<span class="number">0</span>], <span class="number">16</span>);
        <span class="keyword">var</span> t2 = Types.Table(sqrt2[<span class="number">0</span>], <span class="number">16</span>);
        console.assert(t1 === t2);
        console.assert(t1.table);
        console.assert(t1.size === <span class="number">16</span>);
        console.assert(t1.toString() === <span class="string">'((double)-&gt;double)[16]'</span>);
    };
    test_types();</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <h3>Operator and standard library type tables.</h3>
<p>Unary operator types, from
<a href="http://asmjs.org/spec/latest/#unary-operators">http://asmjs.org/spec/latest/#unary-operators</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Types.unary = {
        <span class="string">'+'</span>: Types.FunctionTypes(
            [ Types.Arrow([Types.Signed], Types.Double),
              Types.Arrow([Types.Unsigned], Types.Double),
              Types.Arrow([Types.Doublish], Types.Double) ]),
        <span class="string">'-'</span>: Types.FunctionTypes(
            [ Types.Arrow([Types.Int], Types.Intish),
              Types.Arrow([Types.Doublish], Types.Double) ]),
        <span class="string">'~'</span>: Types.FunctionTypes(
            [ Types.Arrow([Types.Intish], Types.Signed) ]),
        <span class="string">'!'</span>: Types.FunctionTypes(
            [ Types.Arrow([Types.Int], Types.Int) ]),
        <span class="string">'~~'</span>: Types.FunctionTypes(
            [ Types.Arrow([Types.Double], Types.Signed) ])
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>Binary operator types, from
<a href="http://asmjs.org/spec/latest/#binary-operators">http://asmjs.org/spec/latest/#binary-operators</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Types.binary = {
        <span class="string">'+'</span>: Types.FunctionTypes(
            [ Types.Arrow([Types.Double, Types.Double], Types.Double) ]),
        <span class="string">'-'</span>: Types.FunctionTypes(
            [ Types.Arrow([Types.Doublish, Types.Doublish], Types.Double) ]),
        <span class="string">'*'</span>: Types.FunctionTypes(
            [ Types.Arrow([Types.Doublish, Types.Doublish], Types.Double) ]),
        <span class="string">'/'</span>: Types.FunctionTypes(
            [ Types.Arrow([Types.Signed, Types.Signed], Types.Intish),
              Types.Arrow([Types.Unsigned, Types.Unsigned], Types.Intish),
              Types.Arrow([Types.Doublish, Types.Doublish], Types.Double) ]),
        <span class="string">'%'</span>: Types.FunctionTypes(
            [ Types.Arrow([Types.Signed, Types.Signed], Types.Int),
              Types.Arrow([Types.Unsigned, Types.Unsigned], Types.Int),
              Types.Arrow([Types.Doublish, Types.Doublish], Types.Double) ]),
        <span class="string">'&gt;&gt;&gt;'</span>: Types.FunctionTypes(
            [ Types.Arrow([Types.Intish, Types.Intish], Types.Unsigned) ])
    };
    [<span class="string">'|'</span>,<span class="string">'&amp;'</span>,<span class="string">'^'</span>,<span class="string">'&lt;&lt;'</span>,<span class="string">'&gt;&gt;'</span>].forEach(<span class="keyword">function</span>(op) {
        Types.binary[op] = Types.FunctionTypes(
            [ Types.Arrow([Types.Intish, Types.Intish], Types.Signed) ]);
    });
    [<span class="string">'&lt;'</span>,<span class="string">'&lt;='</span>,<span class="string">'&gt;'</span>,<span class="string">'&gt;='</span>,<span class="string">'=='</span>,<span class="string">'!='</span>].forEach(<span class="keyword">function</span>(op) {
        Types.binary[op] = Types.FunctionTypes(
            [ Types.Arrow([Types.Signed, Types.Signed], Types.Int),
              Types.Arrow([Types.Unsigned, Types.Unsigned], Types.Int),
              Types.Arrow([Types.Double, Types.Double], Types.Int) ]);
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>Standard library member types, from
<a href="http://asmjs.org/spec/latest/#standard-library">http://asmjs.org/spec/latest/#standard-library</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Types.stdlib = {
        <span class="string">'Infinity'</span>: Types.Double,
        <span class="string">'NaN'</span>: Types.Double
    };
    [<span class="string">'E'</span>,<span class="string">'LN10'</span>,<span class="string">'LN2'</span>,<span class="string">'LOG2E'</span>,<span class="string">'LOG10E'</span>,<span class="string">'PI'</span>,<span class="string">'SQRT1_2'</span>,<span class="string">'SQRT2'</span>].
        forEach(<span class="keyword">function</span>(f) {
            Types.stdlib[<span class="string">'Math.'</span>+f] = Types.Double;
        });
    [<span class="string">'acos'</span>,<span class="string">'asin'</span>,<span class="string">'atan'</span>,<span class="string">'cos'</span>,<span class="string">'sin'</span>,<span class="string">'tan'</span>,<span class="string">'ceil'</span>,<span class="string">'floor'</span>,<span class="string">'exp'</span>,<span class="string">'log'</span>,<span class="string">'sqrt'</span>].
        forEach(<span class="keyword">function</span>(f) {
            Types.stdlib[<span class="string">'Math.'</span>+f] = Types.FunctionTypes(
                [Types.Arrow([Types.Doublish], Types.Double)]);
        });
    Types.stdlib[<span class="string">'Math.abs'</span>] = Types.FunctionTypes(
        [Types.Arrow([Types.Signed], Types.Unsigned),
         Types.Arrow([Types.Doublish], Types.Double)]);
    Types.stdlib[<span class="string">'Math.atan2'</span>] = Types.stdlib[<span class="string">'Math.pow'</span>] = Types.FunctionTypes(
        [Types.Arrow([Types.Doublish, Types.Doublish], Types.Double)]);
    Types.stdlib[<span class="string">'Math.imul'</span>] = Types.FunctionTypes(
        [Types.Arrow([Types.Int, Types.Int], Types.Signed)]);</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <h2>Tokens</h2>
<p>Some tokenizer functions will have alternate implementations in a
TurtleScript environment -- for example, we&#39;ll try to avoid
using regular expressions and dynamic eval.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> runningInTS = <span class="literal">false</span>; <span class="comment">// XXX replace with an appropriate dynamic test</span></pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>Here we start borrowing liberally from acorn!
We move the token types into module context, since they are
(for all practical purposes) constants.</p>
<h3>Token Types</h3>
<p>The assignment of fine-grained, information-carrying type objects
allows the tokenizer to store the information it has about a
token in a way that is very cheap for the parser to look up.</p>
<p>All token type variables start with an underscore, to make them
easy to recognize.</p>
<p>These are the general types. The <code>type</code> property is only used to
make them recognizeable when debugging.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> _num = {type: <span class="string">"num"</span>};
    <span class="keyword">var</span> _regexp = {type: <span class="string">"regexp"</span>};
    <span class="keyword">var</span> _string = {type: <span class="string">"string"</span>};
    <span class="keyword">var</span> _name = {type: <span class="string">"name"</span>};
    <span class="keyword">var</span> _eof = {type: <span class="string">"eof"</span>};</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p><code>_dotnum</code> is a number with a <code>.</code> character in it; <code>asm.js</code> uses
this to distinguish <code>double</code> from integer literals.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> _dotnum = {type: <span class="string">"dotnum"</span>};</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>Keyword tokens. The <code>keyword</code> property (also used in keyword-like
operators) indicates that the token originated from an
identifier-like word, which is used when parsing property names.</p>
<p>The <code>beforeExpr</code> property is used to disambiguate between regular
expressions and divisions. It is set on all token types that can
be followed by an expression (thus, a slash after them would be a
regular expression).</p>
<p><code>isLoop</code> marks a keyword as starting a loop, which is important
to know when parsing a label, in order to allow or disallow
continue jumps to that label.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> _<span class="keyword">break</span> = {keyword: <span class="string">"break"</span>};
    <span class="keyword">var</span> _<span class="keyword">case</span> = {keyword: <span class="string">"case"</span>, beforeExpr: <span class="literal">true</span>};
    <span class="keyword">var</span> _<span class="keyword">catch</span> = {keyword: <span class="string">"catch"</span>};
    <span class="keyword">var</span> _<span class="keyword">continue</span> = {keyword: <span class="string">"continue"</span>};
    <span class="keyword">var</span> _debugger = {keyword: <span class="string">"debugger"</span>};
    <span class="keyword">var</span> _<span class="keyword">default</span> = {keyword: <span class="string">"default"</span>};
    <span class="keyword">var</span> _<span class="keyword">do</span> = {keyword: <span class="string">"do"</span>, isLoop: <span class="literal">true</span>};
    <span class="keyword">var</span> _<span class="keyword">else</span> = {keyword: <span class="string">"else"</span>, beforeExpr: <span class="literal">true</span>};
    <span class="keyword">var</span> _<span class="keyword">finally</span> = {keyword: <span class="string">"finally"</span>};
    <span class="keyword">var</span> _<span class="keyword">for</span> = {keyword: <span class="string">"for"</span>, isLoop: <span class="literal">true</span>};
    <span class="keyword">var</span> _<span class="keyword">function</span> = {keyword: <span class="string">"function"</span>};
    <span class="keyword">var</span> _<span class="keyword">if</span> = {keyword: <span class="string">"if"</span>};
    <span class="keyword">var</span> _<span class="keyword">return</span> = {keyword: <span class="string">"return"</span>, beforeExpr: <span class="literal">true</span>};
    <span class="keyword">var</span> _<span class="keyword">switch</span> = {keyword: <span class="string">"switch"</span>};
    <span class="keyword">var</span> _<span class="keyword">throw</span> = {keyword: <span class="string">"throw"</span>, beforeExpr: <span class="literal">true</span>};
    <span class="keyword">var</span> _<span class="keyword">try</span> = {keyword: <span class="string">"try"</span>};
    <span class="keyword">var</span> _<span class="keyword">var</span> = {keyword: <span class="string">"var"</span>};
    <span class="keyword">var</span> _<span class="keyword">while</span> = {keyword: <span class="string">"while"</span>, isLoop: <span class="literal">true</span>};
    <span class="keyword">var</span> _<span class="keyword">with</span> = {keyword: <span class="string">"with"</span>};
    <span class="keyword">var</span> _<span class="keyword">new</span> = {keyword: <span class="string">"new"</span>, beforeExpr: <span class="literal">true</span>};
    <span class="keyword">var</span> _<span class="keyword">this</span> = {keyword: <span class="string">"this"</span>};</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>The keywords that denote values.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> _<span class="literal">null</span> = {keyword: <span class="string">"null"</span>, atomValue: <span class="literal">null</span>};
    <span class="keyword">var</span> _<span class="literal">true</span> = {keyword: <span class="string">"true"</span>, atomValue: <span class="literal">true</span>};
    <span class="keyword">var</span> _<span class="literal">false</span> = {keyword: <span class="string">"false"</span>, atomValue: <span class="literal">false</span>};</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>Some keywords are treated as regular operators. <code>in</code> sometimes
(when parsing <code>for</code>) needs to be tested against specifically, so
we assign a variable name to it for quick comparing.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> _<span class="keyword">in</span> = {keyword: <span class="string">"in"</span>, binop: <span class="number">7</span>, beforeExpr: <span class="literal">true</span>};</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>Map keyword names to token types.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> keywordTypes = {
        <span class="string">"break"</span>: _<span class="keyword">break</span>, <span class="string">"case"</span>: _<span class="keyword">case</span>, <span class="string">"catch"</span>: _<span class="keyword">catch</span>,
        <span class="string">"continue"</span>: _<span class="keyword">continue</span>, <span class="string">"debugger"</span>: _debugger, <span class="string">"default"</span>: _<span class="keyword">default</span>,
        <span class="string">"do"</span>: _<span class="keyword">do</span>, <span class="string">"else"</span>: _<span class="keyword">else</span>, <span class="string">"finally"</span>: _<span class="keyword">finally</span>, <span class="string">"for"</span>: _<span class="keyword">for</span>,
        <span class="string">"function"</span>: _<span class="keyword">function</span>, <span class="string">"if"</span>: _<span class="keyword">if</span>, <span class="string">"return"</span>: _<span class="keyword">return</span>,
        <span class="string">"switch"</span>: _<span class="keyword">switch</span>, <span class="string">"throw"</span>: _<span class="keyword">throw</span>, <span class="string">"try"</span>: _<span class="keyword">try</span>, <span class="string">"var"</span>: _<span class="keyword">var</span>,
        <span class="string">"while"</span>: _<span class="keyword">while</span>, <span class="string">"with"</span>: _<span class="keyword">with</span>, <span class="string">"null"</span>: _<span class="literal">null</span>, <span class="string">"true"</span>: _<span class="literal">true</span>,
        <span class="string">"false"</span>: _<span class="literal">false</span>, <span class="string">"new"</span>: _<span class="keyword">new</span>, <span class="string">"in"</span>: _<span class="keyword">in</span>,
        <span class="string">"instanceof"</span>: {keyword: <span class="string">"instanceof"</span>, binop: <span class="number">7</span>, beforeExpr: <span class="literal">true</span>},
        <span class="string">"this"</span>: _<span class="keyword">this</span>,
        <span class="string">"typeof"</span>: {keyword: <span class="string">"typeof"</span>, prefix: <span class="literal">true</span>, beforeExpr: <span class="literal">true</span>},
        <span class="string">"void"</span>: {keyword: <span class="string">"void"</span>, prefix: <span class="literal">true</span>, beforeExpr: <span class="literal">true</span>},
        <span class="string">"delete"</span>: {keyword: <span class="string">"delete"</span>, prefix: <span class="literal">true</span>, beforeExpr: <span class="literal">true</span>}
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>Punctuation token types. Again, the <code>type</code> property is purely for
debugging.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> _bracketL = {type: <span class="string">"["</span>, beforeExpr: <span class="literal">true</span>};
    <span class="keyword">var</span> _bracketR = {type: <span class="string">"]"</span>};
    <span class="keyword">var</span> _braceL = {type: <span class="string">"{"</span>, beforeExpr: <span class="literal">true</span>};
    <span class="keyword">var</span> _braceR = {type: <span class="string">"}"</span>};
    <span class="keyword">var</span> _parenL = {type: <span class="string">"("</span>, beforeExpr: <span class="literal">true</span>};
    <span class="keyword">var</span> _parenR = {type: <span class="string">")"</span>};
    <span class="keyword">var</span> _comma = {type: <span class="string">","</span>, beforeExpr: <span class="literal">true</span>};
    <span class="keyword">var</span> _semi = {type: <span class="string">";"</span>, beforeExpr: <span class="literal">true</span>};
    <span class="keyword">var</span> _colon = {type: <span class="string">":"</span>, beforeExpr: <span class="literal">true</span>};
    <span class="keyword">var</span> _dot = {type: <span class="string">"."</span>};
    <span class="keyword">var</span> _question = {type: <span class="string">"?"</span>, beforeExpr: <span class="literal">true</span>};</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>Operators. These carry several kinds of properties to help the
parser use them properly (the presence of these properties is
what categorizes them as operators).</p>
<p><code>binop</code>, when present, specifies that this operator is a binary
operator, and will refer to its precedence.</p>
<p><code>prefix</code> and <code>postfix</code> mark the operator as a prefix or postfix
unary operator. <code>isUpdate</code> specifies that the node produced by
the operator should be of type UpdateExpression rather than
simply UnaryExpression (<code>++</code> and <code>--</code>).</p>
<p><code>isAssign</code> marks all of <code>=</code>, <code>+=</code>, <code>-=</code> etcetera, which act as
binary operators with a very low precedence, that should result
in AssignmentExpression nodes.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> _slash = {binop: <span class="number">10</span>, beforeExpr: <span class="literal">true</span>};
    <span class="keyword">var</span> _eq = {isAssign: <span class="literal">true</span>, beforeExpr: <span class="literal">true</span>};
    <span class="keyword">var</span> _assign = {isAssign: <span class="literal">true</span>, beforeExpr: <span class="literal">true</span>};
    <span class="keyword">var</span> _plusmin = {binop: <span class="number">9</span>, prefix: <span class="literal">true</span>, beforeExpr: <span class="literal">true</span>};
    <span class="keyword">var</span> _incdec = {postfix: <span class="literal">true</span>, prefix: <span class="literal">true</span>, isUpdate: <span class="literal">true</span>};
    <span class="keyword">var</span> _prefix = {prefix: <span class="literal">true</span>, beforeExpr: <span class="literal">true</span>};
    <span class="keyword">var</span> _bin1 = {binop: <span class="number">1</span>, beforeExpr: <span class="literal">true</span>};
    <span class="keyword">var</span> _bin2 = {binop: <span class="number">2</span>, beforeExpr: <span class="literal">true</span>};
    <span class="keyword">var</span> _bin3 = {binop: <span class="number">3</span>, beforeExpr: <span class="literal">true</span>};
    <span class="keyword">var</span> _bin4 = {binop: <span class="number">4</span>, beforeExpr: <span class="literal">true</span>};
    <span class="keyword">var</span> _bin5 = {binop: <span class="number">5</span>, beforeExpr: <span class="literal">true</span>};
    <span class="keyword">var</span> _bin6 = {binop: <span class="number">6</span>, beforeExpr: <span class="literal">true</span>};
    <span class="keyword">var</span> _bin7 = {binop: <span class="number">7</span>, beforeExpr: <span class="literal">true</span>};
    <span class="keyword">var</span> _bin8 = {binop: <span class="number">8</span>, beforeExpr: <span class="literal">true</span>};
    <span class="keyword">var</span> _bin10 = {binop: <span class="number">10</span>, beforeExpr: <span class="literal">true</span>};</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>Provide access to the token types for external users of the
tokenizer.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    asm_llvm_module.tokTypes = {
        bracketL: _bracketL, bracketR: _bracketR, braceL: _braceL,
        braceR: _braceR, parenL: _parenL, parenR: _parenR, comma: _comma,
        semi: _semi, colon: _colon, dot: _dot, question: _question,
        slash: _slash, eq: _eq, name: _name, eof: _eof, num: _num,
        regexp: _regexp, string: _string, dotnum: _dotnum
    };
    Object.keys(keywordTypes).forEach(<span class="keyword">function</span>(kw) {
        asm_llvm_module.tokTypes[kw] = keywordTypes[kw];
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p>This is a trick taken from Esprima. It turns out that, on
non-Chrome browsers, to check whether a string is in a set, a
predicate containing a big ugly <code>switch</code> statement is faster than
a regular expression, and on Chrome the two are about on par.
This function uses <code>eval</code> (non-lexical) to produce such a
predicate from a space-separated string of words.</p>
<p>It starts by sorting the words by length.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> makePredicate = <span class="keyword">function</span>(words) {
        words = words.split(<span class="string">" "</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p>When running under TurtleScript, substitute a much simpler
implementation (for now at least).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">if</span> (runningInTS) {
            <span class="keyword">return</span> <span class="keyword">function</span>(str) { <span class="keyword">return</span> words.indexOf(str) &gt;= <span class="number">0</span>; };
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p>Otherwise, do the optimized code generation!</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> f = <span class="string">""</span>, cats = [];
        <span class="keyword">var</span> i = <span class="number">0</span>;
        <span class="keyword">while</span> (i &lt; words.length) {
            <span class="keyword">var</span> j = <span class="number">0</span>;
            <span class="keyword">while</span> (j &lt; cats.length) {
                <span class="keyword">if</span> (cats[j][<span class="number">0</span>].length === words[i].length) {
                    cats[j].push(words[i]);
                    <span class="keyword">break</span>;
                }
                j += <span class="number">1</span>;
            }
            <span class="keyword">if</span> (j === cats.length) {
                cats.push([words[i]]);
            }
            i += <span class="number">1</span>;
        }
        <span class="keyword">var</span> compareTo = <span class="keyword">function</span>(arr) {
            <span class="keyword">if</span> (arr.length === <span class="number">1</span>) {
                f += <span class="string">"return str === "</span> + JSON.stringify(arr[<span class="number">0</span>]) + <span class="string">";"</span>;
                <span class="keyword">return</span>;
            }
            f += <span class="string">"switch(str){"</span>;
            arr.forEach(<span class="keyword">function</span>(c) {
                f += <span class="string">"case "</span> + JSON.stringify(c) + <span class="string">":"</span>;
            });
            f += <span class="string">"return true}return false;"</span>;
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p>When there are more than three length categories, an outer
switch first dispatches on the lengths, to save on comparisons.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">if</span> (cats.length &gt; <span class="number">3</span>) {
            cats.sort(<span class="keyword">function</span>(a, b) {<span class="keyword">return</span> b.length - a.length;});
            f += <span class="string">"switch(str.length){"</span>;
            cats.forEach(<span class="keyword">function</span>(cat) {
                f += <span class="string">"case "</span> + cat[<span class="number">0</span>].length + <span class="string">":"</span>;
                compareTo(cat);
            });
            f += <span class="string">"}"</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p>Otherwise, simply generate a flat <code>switch</code> statement.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        } <span class="keyword">else</span> {
            compareTo(words);
        }
        <span class="keyword">return</span> Function.New(<span class="string">"str"</span>, f);
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <p>The ECMAScript 3 reserved word list.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> isReservedWord3 = makePredicate(<span class="string">"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile"</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p>ECMAScript 5 reserved words.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> isReservedWord5 = makePredicate(<span class="string">"class enum extends super const export import"</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p>The additional reserved words in strict mode.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> isStrictReservedWord = makePredicate(<span class="string">"implements interface let package private protected public static yield"</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <p>The forbidden variable names in strict mode.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> isStrictBadIdWord = makePredicate(<span class="string">"eval arguments"</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <p>And the keywords.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> isKeyword = makePredicate(<span class="string">"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this"</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <h2>Character categories</h2>
<p>Big ugly regular expressions that match characters in the
whitespace, identifier, and identifier-start categories. These
are only applied when a character is found to actually have a
code point above 128.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> nonASCIIwhitespace = RegExp.New(<span class="string">"[\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]"</span>);
    <span class="keyword">var</span> nonASCIIidentifierStartChars = <span class="string">"\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc"</span>;
    <span class="keyword">var</span> nonASCIIidentifierChars = <span class="string">"\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u0620-\u0649\u0672-\u06d3\u06e7-\u06e8\u06fb-\u06fc\u0730-\u074a\u0800-\u0814\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0840-\u0857\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962-\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09d7\u09df-\u09e0\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5f-\u0b60\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62-\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2-\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d46-\u0d48\u0d57\u0d62-\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e34-\u0e3a\u0e40-\u0e45\u0e50-\u0e59\u0eb4-\u0eb9\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f41-\u0f47\u0f71-\u0f84\u0f86-\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1029\u1040-\u1049\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u170e-\u1710\u1720-\u1730\u1740-\u1750\u1772\u1773\u1780-\u17b2\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1920-\u192b\u1930-\u193b\u1951-\u196d\u19b0-\u19c0\u19c8-\u19c9\u19d0-\u19d9\u1a00-\u1a15\u1a20-\u1a53\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b46-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1bb0-\u1bb9\u1be6-\u1bf3\u1c00-\u1c22\u1c40-\u1c49\u1c5b-\u1c7d\u1cd0-\u1cd2\u1d00-\u1dbe\u1e01-\u1f15\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2d81-\u2d96\u2de0-\u2dff\u3021-\u3028\u3099\u309a\ua640-\ua66d\ua674-\ua67d\ua69f\ua6f0-\ua6f1\ua7f8-\ua800\ua806\ua80b\ua823-\ua827\ua880-\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8f3-\ua8f7\ua900-\ua909\ua926-\ua92d\ua930-\ua945\ua980-\ua983\ua9b3-\ua9c0\uaa00-\uaa27\uaa40-\uaa41\uaa4c-\uaa4d\uaa50-\uaa59\uaa7b\uaae0-\uaae9\uaaf2-\uaaf3\uabc0-\uabe1\uabec\uabed\uabf0-\uabf9\ufb20-\ufb28\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f"</span>;
    <span class="keyword">var</span> nonASCIIidentifierStart = RegExp.New(<span class="string">"["</span> + nonASCIIidentifierStartChars + <span class="string">"]"</span>);
    <span class="keyword">var</span> nonASCIIidentifier = RegExp.New(<span class="string">"["</span> + nonASCIIidentifierStartChars + nonASCIIidentifierChars + <span class="string">"]"</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <p>Valid RegExp flags.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> validRegExpFlags = RegExp.New(<span class="string">"^[gmsiy]*$"</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-49">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <p>Whether a single character denotes a newline.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> newline = RegExp.New(<span class="string">"[\n\r\u2028\u2029]"</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-50">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>
              <p>Matches a whole line break (where CRLF is considered a single
line break). Used to count lines.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> lineBreak = RegExp.New(<span class="string">"\r\n|[\n\r\u2028\u2029]"</span>, <span class="string">"g"</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-51">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-51">&#182;</a>
              </div>
              <p>Test whether a given character code starts an identifier.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> isIdentifierStart = asm_llvm_module.isIdentifierStart = <span class="keyword">function</span>(code) {
        <span class="keyword">if</span> (code &lt; <span class="number">65</span>) { <span class="keyword">return</span> code === <span class="number">36</span>; }
        <span class="keyword">if</span> (code &lt; <span class="number">91</span>) { <span class="keyword">return</span> <span class="literal">true</span>; }
        <span class="keyword">if</span> (code &lt; <span class="number">97</span>) { <span class="keyword">return</span> code === <span class="number">95</span>; }
        <span class="keyword">if</span> (code &lt; <span class="number">123</span>) { <span class="keyword">return</span> <span class="literal">true</span>; }
        <span class="keyword">return</span> code &gt;= <span class="number">0xaa</span> &amp;&amp;</pre></div></div>
            
        </li>
        
        
        <li id="section-52">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-52">&#182;</a>
              </div>
              <p>Don&#39;t use the regexp if we&#39;re running under TurtleScript.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            (!runningInTS) &amp;&amp;
            nonASCIIidentifierStart.test(String.fromCharCode(code));
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-53">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-53">&#182;</a>
              </div>
              <p>Test whether a given character is part of an identifier.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> isIdentifierChar = asm_llvm_module.isIdentifierChar = <span class="keyword">function</span>(code) {
        <span class="keyword">if</span> (code &lt; <span class="number">48</span>) { <span class="keyword">return</span> code === <span class="number">36</span>; }
        <span class="keyword">if</span> (code &lt; <span class="number">58</span>) { <span class="keyword">return</span> <span class="literal">true</span>; }
        <span class="keyword">if</span> (code &lt; <span class="number">65</span>) { <span class="keyword">return</span> <span class="literal">false</span>; }
        <span class="keyword">if</span> (code &lt; <span class="number">91</span>) { <span class="keyword">return</span> <span class="literal">true</span>; }
        <span class="keyword">if</span> (code &lt; <span class="number">97</span>) { <span class="keyword">return</span> code === <span class="number">95</span>; }
        <span class="keyword">if</span> (code &lt; <span class="number">123</span>) { <span class="keyword">return</span> <span class="literal">true</span>; }
        <span class="keyword">return</span> code &gt;= <span class="number">0xaa</span> &amp;&amp;</pre></div></div>
            
        </li>
        
        
        <li id="section-54">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-54">&#182;</a>
              </div>
              <p>Don&#39;t use the regexp if we&#39;re running under TurtleScript.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            (!runningInTS) &amp;&amp;
            nonASCIIidentifier.test(String.fromCharCode(code));
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-55">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-55">&#182;</a>
              </div>
              <h2>Tokenizer</h2>
<p>Let&#39;s start with the tokenizer.  Unlike acorn, we
encapsulate the tokenizer state so that it is re-entrant.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> Compiler = <span class="keyword">function</span>() {

        <span class="keyword">var</span> options, input, inputLen, sourceFile;</pre></div></div>
            
        </li>
        
        
        <li id="section-56">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-56">&#182;</a>
              </div>
              <p>A second optional argument can be given to further configure
the parser process. These options are recognized:</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> defaultOptions = <span class="keyword">this</span>.defaultOptions = {</pre></div></div>
            
        </li>
        
        
        <li id="section-57">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-57">&#182;</a>
              </div>
              <p><code>ecmaVersion</code> indicates the ECMAScript version to
parse. Must be either 3 or 5. This influences support
for strict mode, the set of reserved words, and support
for getters and setter.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            ecmaVersion: <span class="number">5</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-58">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-58">&#182;</a>
              </div>
              <p>Turn on <code>strictSemicolons</code> to prevent the parser from doing
automatic semicolon insertion.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            strictSemicolons: <span class="literal">false</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-59">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-59">&#182;</a>
              </div>
              <p>When <code>allowTrailingCommas</code> is false, the parser will not allow
trailing commas in array and object literals.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            allowTrailingCommas: <span class="literal">true</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-60">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-60">&#182;</a>
              </div>
              <p>By default, reserved words are not enforced. Enable
<code>forbidReserved</code> to enforce them.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            forbidReserved: <span class="literal">false</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-61">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-61">&#182;</a>
              </div>
              <p>When <code>locations</code> is on, <code>loc</code> properties holding objects with
<code>start</code> and <code>end</code> properties in <code>{line, column}</code> form (with
line being 1-based and column 0-based) will be attached to the
nodes.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            locations: <span class="literal">false</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-62">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-62">&#182;</a>
              </div>
              <p>A function can be passed as <code>onComment</code> option, which will
cause Acorn to call that function with <code>(block, text, start,
end)</code> parameters whenever a comment is skipped. <code>block</code> is a
boolean indicating whether this is a block (<code>/* */</code>) comment,
<code>text</code> is the content of the comment, and <code>start</code> and <code>end</code> are
character offsets that denote the start and end of the comment.
When the <code>locations</code> option is on, two more parameters are
passed, the full <code>{line, column}</code> locations of the start and
end of the comments.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            onComment: <span class="literal">null</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-63">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-63">&#182;</a>
              </div>
              <p>Nodes have their start and end characters offsets recorded in
<code>start</code> and <code>end</code> properties (directly on the node, rather than
the <code>loc</code> object, which holds line/column data. To also add a
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=745678">semi-standardized</a> <code>range</code> property holding a <code>[start,
end]</code> array with the same numbers, set the <code>ranges</code> option to
<code>true</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            ranges: <span class="literal">false</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-64">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-64">&#182;</a>
              </div>
              <p>It is possible to parse multiple files into a single AST by
passing the tree produced by parsing the first file as
<code>program</code> option in subsequent parses. This will add the
toplevel forms of the parsed file to the <code>Program</code> (top) node
of an existing parse tree.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            program: <span class="literal">null</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-65">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-65">&#182;</a>
              </div>
              <p>When <code>location</code> is on, you can pass this to record the source
file in every node&#39;s <code>loc</code> object.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            sourceFile: <span class="literal">null</span>
        };

        <span class="keyword">var</span> setOptions = <span class="keyword">function</span>(opts) {
            options = opts || {};
            Object.keys(defaultOptions).forEach(<span class="keyword">function</span>(opt) {
                <span class="keyword">if</span> (!options.hasOwnProperty(opt)) {
                    options[opt] = defaultOptions[opt];
                }
            });
            sourceFile = options.sourceFile || <span class="literal">null</span>;
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-66">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-66">&#182;</a>
              </div>
              <p>State is kept in variables local to the Tokenizer. We already saw the
<code>options</code>, <code>input</code>, and <code>inputLen</code> variables above.</p>
<p>The current position of the tokenizer in the input.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> tokPos;</pre></div></div>
            
        </li>
        
        
        <li id="section-67">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-67">&#182;</a>
              </div>
              <p>The start and end offsets of the current token.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> tokStart, tokEnd;</pre></div></div>
            
        </li>
        
        
        <li id="section-68">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-68">&#182;</a>
              </div>
              <p>When <code>options.locations</code> is true, these hold objects
containing the tokens start and end line/column pairs.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> tokStartLoc, tokEndLoc;</pre></div></div>
            
        </li>
        
        
        <li id="section-69">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-69">&#182;</a>
              </div>
              <p>The type and value of the current token. Token types are objects,
named by variables against which they can be compared, and
holding properties that describe them (indicating, for example,
the precedence of an infix operator, and the original name of a
keyword token). The kind of value that&#39;s held in <code>tokVal</code> depends
on the type of the token. For literals, it is the literal value,
for operators, the operator name, and so on.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> tokType, tokVal;</pre></div></div>
            
        </li>
        
        
        <li id="section-70">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-70">&#182;</a>
              </div>
              <p>Interal state for the tokenizer. To distinguish between division
operators and regular expressions, it remembers whether the last
token was one that is allowed to be followed by an expression.
(If it is, a slash is probably a regexp, if it isn&#39;t it&#39;s a
division operator. See the <code>parseStatement</code> function for a
caveat.)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> tokRegexpAllowed;</pre></div></div>
            
        </li>
        
        
        <li id="section-71">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-71">&#182;</a>
              </div>
              <p>When <code>options.locations</code> is true, these are used to keep
track of the current line, and know when a new line has been
entered.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> tokCurLine, tokLineStart;</pre></div></div>
            
        </li>
        
        
        <li id="section-72">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-72">&#182;</a>
              </div>
              <p>These store the position of the previous token, which is useful
when finishing a node and assigning its <code>end</code> position.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> lastStart, lastEnd, lastEndLoc;</pre></div></div>
            
        </li>
        
        
        <li id="section-73">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-73">&#182;</a>
              </div>
              <p>This is the parser&#39;s state. <code>inFunction</code> is used to reject
<code>return</code> statements outside of functions, <code>labels</code> to verify that
<code>break</code> and <code>continue</code> have somewhere to jump to, and <code>strict</code>
indicates whether strict mode is on.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> inFunction, labels, strict;</pre></div></div>
            
        </li>
        
        
        <li id="section-74">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-74">&#182;</a>
              </div>
              <p>The <code>getLineInfo</code> function is mostly useful when the
<code>locations</code> option is off (for performance reasons) and you
want to find the line/column position for a given character
offset. <code>input</code> should be the code string that the offset refers
into.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> getLineInfo = <span class="keyword">this</span>.getLineInfo = <span class="keyword">function</span>(input, offset) {
            <span class="keyword">var</span> line = <span class="number">1</span>, cur = <span class="number">0</span>;
            <span class="keyword">while</span> (<span class="literal">true</span>) {
                lineBreak.lastIndex = cur;
                <span class="keyword">var</span> match = lineBreak.exec(input);
                <span class="keyword">if</span> (match &amp;&amp; match.index &lt; offset) {
                    line += <span class="number">1</span>;
                    cur = match.index + match[<span class="number">0</span>].length;
                } <span class="keyword">else</span> { <span class="keyword">break</span>; }
            }
            <span class="keyword">return</span> {line: line, column: offset - cur};
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-75">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-75">&#182;</a>
              </div>
              <p>Forward declarations.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> skipSpace;</pre></div></div>
            
        </li>
        
        
        <li id="section-76">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-76">&#182;</a>
              </div>
              <p>Acorn is organized as a tokenizer and a recursive-descent parser.
The <code>tokenize</code> export provides an interface to the tokenizer.
For asm-llvm.js, we sacrificed a little bit of performance
in order to properly encapsulate the tokenizer.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> initTokenState, readToken;

        <span class="keyword">this</span>.tokenize = <span class="keyword">function</span>(inpt, opts) {
            input = String(inpt); inputLen = input.length;
            setOptions(opts);
            initTokenState();

            <span class="keyword">var</span> t = {};
            <span class="keyword">var</span> getToken = <span class="keyword">function</span>(forceRegexp) {
                readToken(forceRegexp);
                t.start = tokStart; t.end = tokEnd;
                t.startLoc = tokStartLoc; t.endLoc = tokEndLoc;
                t.type = tokType; t.value = tokVal;
                <span class="keyword">return</span> t;
            };
            getToken.jumpTo = <span class="keyword">function</span>(pos, reAllowed) {
                tokPos = pos;
                <span class="keyword">if</span> (options.locations) {
                    tokCurLine = tokLineStart = lineBreak.lastIndex = <span class="number">0</span>;
                    <span class="keyword">var</span> match;
                    <span class="keyword">while</span> ((match = lineBreak.exec(input)) &amp;&amp; match.index &lt; pos) {
                        tokCurLine += <span class="number">1</span>;
                        tokLineStart = match.index + match[<span class="number">0</span>].length;
                    }
                }
                <span class="keyword">var</span> ch = input.charAt(pos - <span class="number">1</span>);
                tokRegexpAllowed = reAllowed;
                skipSpace();
            };
            <span class="keyword">return</span> getToken;
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-77">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-77">&#182;</a>
              </div>
              <p>This function is used to raise exceptions on parse errors. It
takes an offset integer (into the current <code>input</code>) to indicate
the location of the error, attaches the position to the end
of the error message, and then raises a <code>SyntaxError</code> with that
message.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> raise = <span class="function"><span class="keyword">function</span> <span class="params">(pos, message)</span> {</span>
            <span class="keyword">var</span> loc = getLineInfo(input, pos);
            message += <span class="string">" ("</span> + loc.line + <span class="string">":"</span> + loc.column + <span class="string">")"</span>;
            <span class="keyword">var</span> err = SyntaxError.New(message);
            err.pos = pos; err.loc = loc; err.raisedAt = tokPos;
            Object.Throw(err);
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-78">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-78">&#182;</a>
              </div>
              <p>These are used when <code>options.locations</code> is on, for the
<code>tokStartLoc</code> and <code>tokEndLoc</code> properties.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> line_loc_t = <span class="keyword">function</span>() {
            <span class="keyword">this</span>.line = tokCurLine;
            <span class="keyword">this</span>.column = tokPos - tokLineStart;
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-79">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-79">&#182;</a>
              </div>
              <p>Reset the token state. Used at the start of a parse.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        initTokenState = <span class="keyword">function</span>() {
            tokCurLine = <span class="number">1</span>;
            tokPos = tokLineStart = <span class="number">0</span>;
            tokRegexpAllowed = <span class="literal">true</span>;
            skipSpace();
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-80">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-80">&#182;</a>
              </div>
              <p>Called at the end of every token. Sets <code>tokEnd</code>, <code>tokVal</code>, and
<code>tokRegexpAllowed</code>, and skips the space after the token, so that
the next one&#39;s <code>tokStart</code> will point at the right position.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> finishToken = <span class="keyword">function</span>(type, val) {
            tokEnd = tokPos;
            <span class="keyword">if</span> (options.locations) { tokEndLoc = line_loc_t.New(); }
            tokType = type;
            skipSpace();
            tokVal = val;
            tokRegexpAllowed = type.beforeExpr;
        };

        <span class="keyword">var</span> skipBlockComment = <span class="keyword">function</span>() {
            <span class="keyword">var</span> startLoc = options.onComment &amp;&amp; options.locations &amp;&amp; line_loc_t.New();
            <span class="keyword">var</span> start = tokPos, end = input.indexOf(<span class="string">"*/"</span>, tokPos += <span class="number">2</span>);
            <span class="keyword">if</span> (end === -<span class="number">1</span>) { raise(tokPos - <span class="number">2</span>, <span class="string">"Unterminated comment"</span>); }
            tokPos = end + <span class="number">2</span>;
            <span class="keyword">if</span> (options.locations) {
                lineBreak.lastIndex = start;
                <span class="keyword">var</span> match;
                <span class="keyword">while</span> ((match = lineBreak.exec(input)) &amp;&amp; match.index &lt; tokPos) {
                    tokCurLine += <span class="number">1</span>;
                    tokLineStart = match.index + match[<span class="number">0</span>].length;
                }
            }
            <span class="keyword">if</span> (options.onComment) {
                options.onComment(<span class="literal">true</span>, input.slice(start + <span class="number">2</span>, end), start, tokPos,
                                  startLoc, options.locations &amp;&amp; line_loc_t.New());
            }
        };

        <span class="keyword">var</span> skipLineComment = <span class="keyword">function</span>() {
            <span class="keyword">var</span> start = tokPos;
            <span class="keyword">var</span> startLoc = options.onComment &amp;&amp; options.locations &amp;&amp; line_loc_t.New();
            <span class="keyword">var</span> ch = input.charCodeAt(tokPos+=<span class="number">2</span>);
            <span class="keyword">while</span> (tokPos &lt; inputLen &amp;&amp; ch !== <span class="number">10</span> &amp;&amp; ch !== <span class="number">13</span> &amp;&amp; ch !== <span class="number">8232</span> &amp;&amp; ch !== <span class="number">8329</span>) {
                tokPos += <span class="number">1</span>;
                ch = input.charCodeAt(tokPos);
            }
            <span class="keyword">if</span> (options.onComment) {
                options.onComment(<span class="literal">false</span>, input.slice(start + <span class="number">2</span>, tokPos), start, tokPos,
                                  startLoc, options.locations &amp;&amp; line_loc_t.New());
            }
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-81">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-81">&#182;</a>
              </div>
              <p>Called at the start of the parse and after every token. Skips
whitespace and comments, and.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        skipSpace = <span class="keyword">function</span>() {
            <span class="keyword">while</span> (tokPos &lt; inputLen) {
                <span class="keyword">var</span> ch = input.charCodeAt(tokPos);
                <span class="keyword">var</span> next;
                <span class="keyword">if</span> (ch === <span class="number">32</span>) { <span class="comment">// ' '</span>
                    tokPos += <span class="number">1</span>;
                } <span class="keyword">else</span> <span class="keyword">if</span>(ch === <span class="number">13</span>) {
                    tokPos += <span class="number">1</span>;
                    next = input.charCodeAt(tokPos);
                    <span class="keyword">if</span>(next === <span class="number">10</span>) {
                        tokPos += <span class="number">1</span>;
                    }
                    <span class="keyword">if</span>(options.locations) {
                        tokCurLine += <span class="number">1</span>;
                        tokLineStart = tokPos;
                    }
                } <span class="keyword">else</span> <span class="keyword">if</span> (ch === <span class="number">10</span>) {
                    tokPos += <span class="number">1</span>;
                    tokCurLine += <span class="number">1</span>;
                    tokLineStart = tokPos;
                } <span class="keyword">else</span> <span class="keyword">if</span>(ch &lt; <span class="number">14</span> &amp;&amp; ch &gt; <span class="number">8</span>) {
                    tokPos += <span class="number">1</span>;
                } <span class="keyword">else</span> <span class="keyword">if</span> (ch === <span class="number">47</span>) { <span class="comment">// '/'</span>
                    next = input.charCodeAt(tokPos+<span class="number">1</span>);
                    <span class="keyword">if</span> (next === <span class="number">42</span>) { <span class="comment">// '*'</span>
                        skipBlockComment();
                    } <span class="keyword">else</span> <span class="keyword">if</span> (next === <span class="number">47</span>) { <span class="comment">// '/'</span>
                        skipLineComment();
                    } <span class="keyword">else</span> { <span class="keyword">break</span>; }
                } <span class="keyword">else</span> <span class="keyword">if</span> ((ch &lt; <span class="number">14</span> &amp;&amp; ch &gt; <span class="number">8</span>) || ch === <span class="number">32</span> || ch === <span class="number">160</span>) { <span class="comment">// ' ', '\xa0'</span>
                    tokPos += <span class="number">1</span>;
                } <span class="keyword">else</span> <span class="keyword">if</span> (ch &gt;= <span class="number">5760</span> &amp;&amp;</pre></div></div>
            
        </li>
        
        
        <li id="section-82">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-82">&#182;</a>
              </div>
              <p>Don&#39;t use the regexp if we&#39;re running under
TurtleScript.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                           (!options.runningInTS) &amp;&amp;
                           nonASCIIwhitespace.test(String.fromCharCode(ch))) {
                    tokPos += <span class="number">1</span>;
                } <span class="keyword">else</span> {
                    <span class="keyword">break</span>;
                }
            }
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-83">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-83">&#182;</a>
              </div>
              <h3>Token reading</h3>
<p>This is the function that is called to fetch the next token. It
is somewhat obscure, because it works in character codes rather
than characters, and because operator parsing has been inlined
into it.</p>
<p>All in the name of speed.</p>
<p>The <code>forceRegexp</code> parameter is used in the one case where the
<code>tokRegexpAllowed</code> trick does not work. See <code>parseStatement</code>.</p>
<p>Forward declarations.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> readNumber, readHexNumber, readRegexp, readString;
        <span class="keyword">var</span> readWord, readWord1, finishOp;

        <span class="keyword">var</span> readToken_dot = <span class="keyword">function</span>() {
            <span class="keyword">var</span> next = input.charCodeAt(tokPos+<span class="number">1</span>);
            <span class="keyword">if</span> (next &gt;= <span class="number">48</span> &amp;&amp; next &lt;= <span class="number">57</span>) { <span class="keyword">return</span> readNumber(<span class="literal">true</span>); }
            tokPos += <span class="number">1</span>;
            <span class="keyword">return</span> finishToken(_dot);
        };

        <span class="keyword">var</span> readToken_slash = <span class="keyword">function</span>() { <span class="comment">// '/'</span>
            <span class="keyword">var</span> next = input.charCodeAt(tokPos+<span class="number">1</span>);
            <span class="keyword">if</span> (tokRegexpAllowed) { tokPos += <span class="number">1</span>; <span class="keyword">return</span> readRegexp(); }
            <span class="keyword">if</span> (next === <span class="number">61</span>) { <span class="keyword">return</span> finishOp(_assign, <span class="number">2</span>); }
            <span class="keyword">return</span> finishOp(_slash, <span class="number">1</span>);
        };

        <span class="keyword">var</span> readToken_mult_modulo = <span class="keyword">function</span>() { <span class="comment">// '%*'</span>
            <span class="keyword">var</span> next = input.charCodeAt(tokPos+<span class="number">1</span>);
            <span class="keyword">if</span> (next === <span class="number">61</span>) { <span class="keyword">return</span> finishOp(_assign, <span class="number">2</span>); }
            <span class="keyword">return</span> finishOp(_bin10, <span class="number">1</span>);
        };

        <span class="keyword">var</span> readToken_pipe_amp = <span class="keyword">function</span>(code) { <span class="comment">// '|&amp;'</span>
            <span class="keyword">var</span> next = input.charCodeAt(tokPos+<span class="number">1</span>);
            <span class="keyword">if</span> (next === code) {
                <span class="keyword">return</span> finishOp(code === <span class="number">124</span> ? _bin1 : _bin2, <span class="number">2</span>);
            }
            <span class="keyword">if</span> (next === <span class="number">61</span>) { <span class="keyword">return</span> finishOp(_assign, <span class="number">2</span>); }
            <span class="keyword">return</span> finishOp(code === <span class="number">124</span> ? _bin3 : _bin5, <span class="number">1</span>);
        };

        <span class="keyword">var</span> readToken_caret = <span class="keyword">function</span>() { <span class="comment">// '^'</span>
            <span class="keyword">var</span> next = input.charCodeAt(tokPos+<span class="number">1</span>);
            <span class="keyword">if</span> (next === <span class="number">61</span>) { <span class="keyword">return</span> finishOp(_assign, <span class="number">2</span>); }
            <span class="keyword">return</span> finishOp(_bin4, <span class="number">1</span>);
        };

        <span class="keyword">var</span> readToken_plus_min = <span class="keyword">function</span>(code) { <span class="comment">// '+-'</span>
            <span class="keyword">var</span> next = input.charCodeAt(tokPos+<span class="number">1</span>);
            <span class="keyword">if</span> (next === code) { <span class="keyword">return</span> finishOp(_incdec, <span class="number">2</span>); }
            <span class="keyword">if</span> (next === <span class="number">61</span>) { <span class="keyword">return</span> finishOp(_assign, <span class="number">2</span>); }
            <span class="keyword">return</span> finishOp(_plusmin, <span class="number">1</span>);
        };

        <span class="keyword">var</span> readToken_lt_gt = <span class="keyword">function</span>(code) { <span class="comment">// '&lt;&gt;'</span>
            <span class="keyword">var</span> next = input.charCodeAt(tokPos+<span class="number">1</span>);
            <span class="keyword">var</span> size = <span class="number">1</span>;
            <span class="keyword">if</span> (next === code) {
                size = code === <span class="number">62</span> &amp;&amp; input.charCodeAt(tokPos+<span class="number">2</span>) === <span class="number">62</span> ? <span class="number">3</span> : <span class="number">2</span>;
                <span class="keyword">if</span> (input.charCodeAt(tokPos + size) === <span class="number">61</span>) {
                    <span class="keyword">return</span> finishOp(_assign, size + <span class="number">1</span>);
                }
                <span class="keyword">return</span> finishOp(_bin8, size);
            }
            <span class="keyword">if</span> (next === <span class="number">61</span>) {
                size = input.charCodeAt(tokPos+<span class="number">2</span>) === <span class="number">61</span> ? <span class="number">3</span> : <span class="number">2</span>;
            }
            <span class="keyword">return</span> finishOp(_bin7, size);
        };

        <span class="keyword">var</span> readToken_eq_excl = <span class="keyword">function</span>(code) { <span class="comment">// '=!'</span>
            <span class="keyword">var</span> next = input.charCodeAt(tokPos+<span class="number">1</span>);
            <span class="keyword">if</span> (next === <span class="number">61</span>) {
                <span class="keyword">return</span> finishOp(_bin6, input.charCodeAt(tokPos+<span class="number">2</span>) === <span class="number">61</span> ? <span class="number">3</span> : <span class="number">2</span>);
            }
            <span class="keyword">return</span> finishOp(code === <span class="number">61</span> ? _eq : _prefix, <span class="number">1</span>);
        };

        <span class="keyword">var</span> readToken_tilde = <span class="keyword">function</span>(code) {
            <span class="keyword">var</span> next = input.charCodeAt(tokPos+<span class="number">1</span>);
            <span class="keyword">if</span> (next === code) { <span class="keyword">return</span> finishOp(_prefix, <span class="number">2</span>); } <span class="comment">// ~~</span>
            <span class="keyword">return</span> finishOp(_prefix, <span class="number">1</span>);
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-84">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-84">&#182;</a>
              </div>
              <p>This is a switch statement in the original acorn tokenizer.
We don&#39;t support the &#39;switch&#39; syntax in TurtleScript, so use
an equivalent (but maybe slightly slower) table-of-functions.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> tokenFromCodeTable = (<span class="keyword">function</span>() {
            <span class="keyword">var</span> table = [];
            <span class="keyword">var</span> defaultAction = <span class="keyword">function</span>() { <span class="keyword">return</span> <span class="literal">false</span>; };
            <span class="keyword">while</span> (table.length &lt; <span class="number">128</span>) {
                table[table.length] = defaultAction;
            }
            <span class="keyword">return</span> table;
        })();

        <span class="keyword">var</span> getTokenFromCode = <span class="keyword">function</span>(code) {
            <span class="keyword">return</span> (code &lt; tokenFromCodeTable.length) ?
                tokenFromCodeTable[code](code) : <span class="literal">false</span>;
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-85">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-85">&#182;</a>
              </div>
              <p>The interpretation of a dot depends on whether it is followed
by a digit.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        tokenFromCodeTable[<span class="number">46</span>] = <span class="comment">// '.'</span>
            readToken_dot;</pre></div></div>
            
        </li>
        
        
        <li id="section-86">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-86">&#182;</a>
              </div>
              <p>Punctuation tokens.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        tokenFromCodeTable[<span class="number">40</span>] =
            <span class="keyword">function</span>() { tokPos += <span class="number">1</span>; <span class="keyword">return</span> finishToken(_parenL); };
        tokenFromCodeTable[<span class="number">41</span>] =
            <span class="keyword">function</span>() { tokPos += <span class="number">1</span>; <span class="keyword">return</span> finishToken(_parenR); };
        tokenFromCodeTable[<span class="number">59</span>] =
            <span class="keyword">function</span>() { tokPos += <span class="number">1</span>; <span class="keyword">return</span> finishToken(_semi); };
        tokenFromCodeTable[<span class="number">44</span>] =
            <span class="keyword">function</span>() { tokPos += <span class="number">1</span>; <span class="keyword">return</span> finishToken(_comma); };
        tokenFromCodeTable[<span class="number">91</span>] =
            <span class="keyword">function</span>() { tokPos += <span class="number">1</span>; <span class="keyword">return</span> finishToken(_bracketL); };
        tokenFromCodeTable[<span class="number">93</span>] =
            <span class="keyword">function</span>() { tokPos += <span class="number">1</span>; <span class="keyword">return</span> finishToken(_bracketR); };
        tokenFromCodeTable[<span class="number">123</span>] =
            <span class="keyword">function</span>() { tokPos += <span class="number">1</span>; <span class="keyword">return</span> finishToken(_braceL); };
        tokenFromCodeTable[<span class="number">125</span>] =
            <span class="keyword">function</span>() { tokPos += <span class="number">1</span>; <span class="keyword">return</span> finishToken(_braceR); };
        tokenFromCodeTable[<span class="number">58</span>] =
            <span class="keyword">function</span>() { tokPos += <span class="number">1</span>; <span class="keyword">return</span> finishToken(_colon); };
        tokenFromCodeTable[<span class="number">63</span>] =
            <span class="keyword">function</span>() { tokPos += <span class="number">1</span>; <span class="keyword">return</span> finishToken(_question); };</pre></div></div>
            
        </li>
        
        
        <li id="section-87">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-87">&#182;</a>
              </div>
              <p>&#39;0x&#39; is a hexadecimal number.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        tokenFromCodeTable[<span class="number">48</span>] = <span class="comment">// '0'</span>
            <span class="keyword">function</span>() {
                <span class="keyword">var</span> next = input.charCodeAt(tokPos+<span class="number">1</span>);
                <span class="keyword">if</span> (next === <span class="number">120</span> || next === <span class="number">88</span>) { <span class="keyword">return</span> readHexNumber(); }</pre></div></div>
            
        </li>
        
        
        <li id="section-88">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-88">&#182;</a>
              </div>
              <p>Anything else beginning with a digit is an integer, octal
number, or float.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="keyword">return</span> readNumber(<span class="literal">false</span>);
            };
        tokenFromCodeTable[<span class="number">49</span>] = tokenFromCodeTable[<span class="number">50</span>] =
            tokenFromCodeTable[<span class="number">51</span>] = tokenFromCodeTable[<span class="number">52</span>] =
            tokenFromCodeTable[<span class="number">53</span>] = tokenFromCodeTable[<span class="number">54</span>] =
            tokenFromCodeTable[<span class="number">55</span>] = tokenFromCodeTable[<span class="number">56</span>] =
            tokenFromCodeTable[<span class="number">57</span>] = <span class="comment">// 1-9</span>
            <span class="keyword">function</span>() { <span class="keyword">return</span> readNumber(<span class="literal">false</span>); };</pre></div></div>
            
        </li>
        
        
        <li id="section-89">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-89">&#182;</a>
              </div>
              <p>Quotes produce strings.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        tokenFromCodeTable[<span class="number">34</span>] = tokenFromCodeTable[<span class="number">39</span>] = <span class="comment">// '"', "'"</span>
            <span class="keyword">function</span>(code) { <span class="keyword">return</span> readString(code); };</pre></div></div>
            
        </li>
        
        
        <li id="section-90">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-90">&#182;</a>
              </div>
              <p>Operators are parsed inline in tiny state machines. &#39;=&#39; (61) is
often referred to. <code>finishOp</code> simply skips the amount of
characters it is given as second argument, and returns a token
of the type given by its first argument.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        tokenFromCodeTable[<span class="number">47</span>] = <span class="comment">// '/'</span>
            readToken_slash;

        tokenFromCodeTable[<span class="number">37</span>] = tokenFromCodeTable[<span class="number">42</span>] = <span class="comment">// '%*'</span>
            readToken_mult_modulo;

        tokenFromCodeTable[<span class="number">124</span>] = tokenFromCodeTable[<span class="number">38</span>] = <span class="comment">// '|&amp;'</span>
            readToken_pipe_amp;

        tokenFromCodeTable[<span class="number">94</span>] = <span class="comment">// '^'</span>
            readToken_caret;

        tokenFromCodeTable[<span class="number">43</span>] = tokenFromCodeTable[<span class="number">45</span>] = <span class="comment">// '+-'</span>
            readToken_plus_min;

        tokenFromCodeTable[<span class="number">60</span>] = tokenFromCodeTable[<span class="number">62</span>] = <span class="comment">// '&lt;&gt;'</span>
            readToken_lt_gt;

        tokenFromCodeTable[<span class="number">61</span>] = tokenFromCodeTable[<span class="number">33</span>] = <span class="comment">// '=!'</span>
            readToken_eq_excl;

        tokenFromCodeTable[<span class="number">126</span>] = <span class="comment">// '~'</span>
            readToken_tilde;</pre></div></div>
            
        </li>
        
        
        <li id="section-91">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-91">&#182;</a>
              </div>
              <p>XXX: forceRegexp is never true for asm.js</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        readToken = <span class="keyword">function</span>(forceRegexp) {
            <span class="keyword">if</span> (!forceRegexp) { tokStart = tokPos; }
            <span class="keyword">else</span> { tokPos = tokStart + <span class="number">1</span>; }
            <span class="keyword">if</span> (options.locations) { tokStartLoc = line_loc_t.New(); }
            <span class="keyword">if</span> (forceRegexp) { <span class="keyword">return</span> readRegexp(); }
            <span class="keyword">if</span> (tokPos &gt;= inputLen) { <span class="keyword">return</span> finishToken(_eof); }

            <span class="keyword">var</span> code = input.charCodeAt(tokPos);</pre></div></div>
            
        </li>
        
        
        <li id="section-92">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-92">&#182;</a>
              </div>
              <p>Identifier or keyword. &#39;\uXXXX&#39; sequences are allowed in
identifiers, so &#39;\&#39; also dispatches to that.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">if</span> (isIdentifierStart(code) || code === <span class="number">92</span> <span class="comment">/* '\' */</span>) {
                <span class="keyword">return</span> readWord();
            }

            <span class="keyword">var</span> tok = getTokenFromCode(code);

            <span class="keyword">if</span> (tok === <span class="literal">false</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-93">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-93">&#182;</a>
              </div>
              <p>If we are here, we either found a non-ASCII identifier
character, or something that&#39;s entirely disallowed.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="keyword">var</span> ch = String.fromCharCode(code);
                <span class="keyword">if</span> (ch === <span class="string">"\\"</span> ||</pre></div></div>
            
        </li>
        
        
        <li id="section-94">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-94">&#182;</a>
              </div>
              <p>Don&#39;t use the regexp if we&#39;re running under TurtleScript.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    ((!options.runningInTS) &amp;&amp;
                     nonASCIIidentifierStart.test(ch))) {
                    <span class="keyword">return</span> readWord();
                }
                raise(tokPos, <span class="string">"Unexpected character '"</span> + ch + <span class="string">"'"</span>);
            }
            <span class="keyword">return</span> tok;
        };

        finishOp = <span class="keyword">function</span>(type, size) {
            <span class="keyword">var</span> str = input.slice(tokPos, tokPos + size);
            tokPos += size;
            finishToken(type, str);
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-95">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-95">&#182;</a>
              </div>
              <p>Parse a regular expression. Some context-awareness is necessary,
since a &#39;/&#39; inside a &#39;[]&#39; set does not end the expression.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        readRegexp = <span class="keyword">function</span>() {
            <span class="keyword">var</span> escaped, inClass, start = tokPos;
            <span class="keyword">while</span> (<span class="literal">true</span>) {
                <span class="keyword">if</span> (tokPos &gt;= inputLen) {
                    raise(start, <span class="string">"Unterminated regular expression"</span>);
                }
                <span class="keyword">var</span> ch = input.charAt(tokPos);
                <span class="keyword">if</span> (newline.test(ch)) {
                    raise(start, <span class="string">"Unterminated regular expression"</span>);
                }
                <span class="keyword">if</span> (!escaped) {
                    <span class="keyword">if</span> (ch === <span class="string">"["</span>) { inClass = <span class="literal">true</span>; }
                    <span class="keyword">else</span> <span class="keyword">if</span> (ch === <span class="string">"]"</span> &amp;&amp; inClass) { inClass = <span class="literal">false</span>; }
                    <span class="keyword">else</span> <span class="keyword">if</span> (ch === <span class="string">"/"</span> &amp;&amp; !inClass) { <span class="keyword">break</span>; }
                    escaped = ch === <span class="string">"\\"</span>;
                } <span class="keyword">else</span> { escaped = <span class="literal">false</span>; }
                tokPos += <span class="number">1</span>;
            }
            <span class="keyword">var</span> content = input.slice(start, tokPos);
            tokPos += <span class="number">1</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-96">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-96">&#182;</a>
              </div>
              <p>Need to use <code>readWord1</code> because &#39;\uXXXX&#39; sequences are allowed
here (don&#39;t ask).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">var</span> mods = readWord1();
            <span class="keyword">if</span> (mods &amp;&amp; (!runningInTS) &amp;&amp; !validRegExpFlags.test(mods)) {
                raise(start, <span class="string">"Invalid regexp flag"</span>);
            }
            <span class="keyword">return</span> finishToken(_regexp, RegExp.New(content, mods));
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-97">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-97">&#182;</a>
              </div>
              <p>Read an integer in the given radix. Return null if zero digits
were read, the integer value otherwise. When <code>len</code> is given, this
will return <code>null</code> unless the integer has exactly <code>len</code> digits.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> readInt = <span class="keyword">function</span>(radix, len) {
            <span class="keyword">var</span> start = tokPos, total = <span class="number">0</span>;
            <span class="keyword">var</span> i = <span class="number">0</span>, e = (len === <span class="literal">undefined</span>) ? <span class="literal">Infinity</span> : len;
            <span class="keyword">while</span> (i &lt; e) {
                <span class="keyword">var</span> code = input.charCodeAt(tokPos), val;
                <span class="keyword">if</span> (code &gt;= <span class="number">97</span>) { val = code - <span class="number">97</span> + <span class="number">10</span>; } <span class="comment">// a</span>
                <span class="keyword">else</span> <span class="keyword">if</span> (code &gt;= <span class="number">65</span>) { val = code - <span class="number">65</span> + <span class="number">10</span>; } <span class="comment">// A</span>
                <span class="keyword">else</span> <span class="keyword">if</span> (code &gt;= <span class="number">48</span> &amp;&amp; code &lt;= <span class="number">57</span>) { val = code - <span class="number">48</span>; } <span class="comment">// 0-9</span>
                <span class="keyword">else</span> { val = <span class="literal">Infinity</span>; }
                <span class="keyword">if</span> (val &gt;= radix) { <span class="keyword">break</span>; }
                tokPos += <span class="number">1</span>;
                total = total * radix + val;
                i += <span class="number">1</span>;
            }
            <span class="keyword">if</span> (tokPos === start ||
                (len !== <span class="literal">undefined</span> &amp;&amp; tokPos - start !== len)) {
                <span class="keyword">return</span> <span class="literal">null</span>;
            }

            <span class="keyword">return</span> total;
        };

        readHexNumber = <span class="keyword">function</span>() {
            tokPos += <span class="number">2</span>; <span class="comment">// 0x</span>
            <span class="keyword">var</span> val = readInt(<span class="number">16</span>);
            <span class="keyword">if</span> (val === <span class="literal">null</span>) {
                raise(tokStart + <span class="number">2</span>, <span class="string">"Expected hexadecimal number"</span>);
            }
            <span class="keyword">if</span> (isIdentifierStart(input.charCodeAt(tokPos))) {
                raise(tokPos, <span class="string">"Identifier directly after number"</span>);
            }
            <span class="keyword">return</span> finishToken(_num, val);
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-98">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-98">&#182;</a>
              </div>
              <p>Read an integer, octal integer, or floating-point number.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        readNumber = <span class="keyword">function</span>(startsWithDot) {
            <span class="keyword">var</span> start = tokPos, isFloat = <span class="literal">false</span>, hasDot = <span class="literal">false</span>;
            <span class="keyword">var</span> octal = input.charCodeAt(tokPos) === <span class="number">48</span>;
            <span class="keyword">if</span> (!startsWithDot &amp;&amp; readInt(<span class="number">10</span>) === <span class="literal">null</span>) {
                raise(start, <span class="string">"Invalid number"</span>);
            }
            <span class="keyword">if</span> (input.charCodeAt(tokPos) === <span class="number">46</span>) { <span class="comment">// '.'</span>
                tokPos += <span class="number">1</span>;
                readInt(<span class="number">10</span>);
                isFloat = hasDot = <span class="literal">true</span>;
            }
            <span class="keyword">var</span> next = input.charCodeAt(tokPos);
            <span class="keyword">if</span> (next === <span class="number">69</span> || next === <span class="number">101</span>) { <span class="comment">// 'eE'</span>
                tokPos += <span class="number">1</span>;
                next = input.charCodeAt(tokPos);
                <span class="keyword">if</span> (next === <span class="number">43</span> || next === <span class="number">45</span>) { tokPos += <span class="number">1</span>; } <span class="comment">// '+-'</span>
                <span class="keyword">if</span> (readInt(<span class="number">10</span>) === <span class="literal">null</span>) { raise(start, <span class="string">"Invalid number"</span>); }
                isFloat = <span class="literal">true</span>;
            }
            <span class="keyword">if</span> (isIdentifierStart(input.charCodeAt(tokPos))) {
                raise(tokPos, <span class="string">"Identifier directly after number"</span>);
            }

            <span class="keyword">var</span> str = input.slice(start, tokPos), val;
            <span class="keyword">if</span> (isFloat) { val = parseFloat(str); }
            <span class="keyword">else</span> <span class="keyword">if</span> (!octal || str.length === <span class="number">1</span>) { val = parseInt(str, <span class="number">10</span>); }
            <span class="keyword">else</span> <span class="keyword">if</span> (str.indexOf(<span class="string">'8'</span>) &gt;= <span class="number">0</span> || str.indexOf(<span class="string">'9'</span>) &gt;= <span class="number">0</span> || strict) {
                raise(start, <span class="string">"Invalid number"</span>);
            }
            <span class="keyword">else</span> { val = parseInt(str, <span class="number">8</span>); }
            <span class="keyword">return</span> finishToken(hasDot ? _dotnum : _num, val);
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-99">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-99">&#182;</a>
              </div>
              <p>Used to read character escape sequences (&#39;\x&#39;, &#39;\u&#39;, &#39;\U&#39;).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> readHexChar = <span class="keyword">function</span>(len) {
            <span class="keyword">var</span> n = readInt(<span class="number">16</span>, len);
            <span class="keyword">if</span> (n === <span class="literal">null</span>) {
                raise(tokStart, <span class="string">"Bad character escape sequence"</span>);
            }
            <span class="keyword">return</span> n;
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-100">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-100">&#182;</a>
              </div>
              <p>Read a string value, interpreting backslash-escapes.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        readString = <span class="keyword">function</span>(quote) {
            tokPos += <span class="number">1</span>;
            <span class="keyword">var</span> out = <span class="string">""</span>;
            <span class="keyword">while</span> (<span class="literal">true</span>) {
                <span class="keyword">if</span> (tokPos &gt;= inputLen) {
                    raise(tokStart, <span class="string">"Unterminated string constant"</span>);
                }
                <span class="keyword">var</span> ch = input.charCodeAt(tokPos);
                <span class="keyword">if</span> (ch === quote) {
                    tokPos += <span class="number">1</span>;
                    <span class="keyword">return</span> finishToken(_string, out);
                }
                <span class="keyword">if</span> (ch === <span class="number">92</span>) { <span class="comment">// '\'</span>
                    tokPos += <span class="number">1</span>;
                    ch = input.charCodeAt(tokPos);
                    <span class="keyword">var</span> octalStop = <span class="number">0</span>, octal = <span class="literal">null</span>;
                    <span class="keyword">while</span> (octalStop &lt; <span class="number">3</span> &amp;&amp;
                           ch &gt;= <span class="number">0x30</span> <span class="comment">/* '0' */</span> &amp;&amp; ch &lt;= <span class="number">0x37</span> <span class="comment">/* '7' */</span>) {
                        octalStop += <span class="number">1</span>;
                        ch = input.charCodeAt(tokPos + octalStop);
                    }
                    <span class="keyword">if</span> (octalStop) {
                        octal = input.slice(tokPos, tokPos + octalStop);
                        ch = input.charCodeAt(tokPos);
                    }
                    <span class="keyword">while</span> (octal &amp;&amp; parseInt(octal, <span class="number">8</span>) &gt; <span class="number">255</span>) {
                        octal = octal.slice(<span class="number">0</span>, octal.length - <span class="number">1</span>);
                    }
                    <span class="keyword">if</span> (octal === <span class="string">"0"</span>) { octal = <span class="literal">null</span>; }
                    tokPos += <span class="number">1</span>;
                    <span class="keyword">if</span> (octal) {
                        <span class="keyword">if</span> (strict) {
                            raise(tokPos - <span class="number">2</span>, <span class="string">"Octal literal in strict mode"</span>);
                        }
                        out += String.fromCharCode(parseInt(octal, <span class="number">8</span>));
                        tokPos += octal.length - <span class="number">1</span>;
                    } <span class="keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-101">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-101">&#182;</a>
              </div>
              <p>This was a switch statement in acorn; we turned it
into a binary search tree of ifs instead.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                        <span class="keyword">if</span> (ch &lt; <span class="number">110</span>) { <span class="comment">// 10,13,48,85,98,102</span>
                            <span class="keyword">if</span> (ch &lt; <span class="number">85</span>) { <span class="comment">// 10,13,48</span>
                                <span class="keyword">if</span> (ch===<span class="number">10</span> || ch===<span class="number">13</span>) { <span class="comment">// '\r' or '\n'</span>
                                    <span class="keyword">if</span> (ch===<span class="number">13</span>) {
                                        <span class="keyword">if</span> (input.charCodeAt(tokPos) === <span class="number">10</span>) {
                                            tokPos += <span class="number">1</span>; <span class="comment">// '\r\n'</span>
                                        }
                                    }
                                    <span class="keyword">if</span> (options.locations) {
                                        tokLineStart = tokPos; tokCurLine += <span class="number">1</span>;
                                    }
                                } <span class="keyword">else</span> <span class="keyword">if</span> (ch === <span class="number">48</span>) {
                                    out += <span class="string">"\0"</span>; <span class="keyword">break</span>; <span class="comment">// 0 -&gt; '\0'</span>
                                } <span class="keyword">else</span> { <span class="comment">// default case</span>
                                    out += String.fromCharCode(ch);
                                }
                            } <span class="keyword">else</span> { <span class="comment">// 85,98,102</span>
                                <span class="keyword">if</span> (ch === <span class="number">85</span>) { <span class="comment">// 'U'</span>
                                    out += String.fromCharCode(readHexChar(<span class="number">8</span>));
                                } <span class="keyword">else</span> <span class="keyword">if</span> (ch === <span class="number">98</span>) { <span class="comment">// 'b' -&gt; '\b'</span>
                                    out += <span class="string">"\b"</span>;
                                } <span class="keyword">else</span> <span class="keyword">if</span> (ch === <span class="number">102</span>) { <span class="comment">// 'f' -&gt; '\f'</span>
                                    out += <span class="string">"\f"</span>;
                                } <span class="keyword">else</span> { <span class="comment">// default case</span>
                                    out += String.fromCharCode(ch);
                                }
                            }
                        } <span class="keyword">else</span> { <span class="comment">// 110,114,116,117,118,120</span>
                            <span class="keyword">if</span> (ch &lt; <span class="number">117</span>) { <span class="comment">// 110,114,116</span>
                                <span class="keyword">if</span> (ch===<span class="number">110</span>) { <span class="comment">// 'n' -&gt; '\n'</span>
                                    out += <span class="string">"\n"</span>;
                                } <span class="keyword">else</span> <span class="keyword">if</span> (ch === <span class="number">114</span>) { <span class="comment">// 'r' -&gt; '\r'</span>
                                    out += <span class="string">"\r"</span>;
                                } <span class="keyword">else</span> <span class="keyword">if</span> (ch === <span class="number">116</span>) { <span class="comment">// 't' -&gt; '\t'</span>
                                    out += <span class="string">"\t"</span>;
                                } <span class="keyword">else</span> { <span class="comment">// default case</span>
                                    out += String.fromCharCode(ch);
                                }
                            } <span class="keyword">else</span> { <span class="comment">// 117,118,120</span>
                                <span class="keyword">if</span> (ch===<span class="number">117</span>) { <span class="comment">// 'u'</span>
                                    out += String.fromCharCode(readHexChar(<span class="number">4</span>));
                                } <span class="keyword">else</span> <span class="keyword">if</span> (ch===<span class="number">118</span>) { <span class="comment">// 'v' -&gt; '\u000b'</span>
                                    out += <span class="string">"\u000b"</span>;
                                } <span class="keyword">else</span> <span class="keyword">if</span> (ch===<span class="number">120</span>) { <span class="comment">// 'x'</span>
                                    out += String.fromCharCode(readHexChar(<span class="number">2</span>));
                                } <span class="keyword">else</span> { <span class="comment">// default case</span>
                                    out += String.fromCharCode(ch);
                                }
                            }
                        }
                    }
                } <span class="keyword">else</span> {
                    <span class="keyword">if</span> (ch === <span class="number">13</span> || ch === <span class="number">10</span> || ch === <span class="number">8232</span> || ch === <span class="number">8329</span>) {
                        raise(tokStart, <span class="string">"Unterminated string constant"</span>);
                    }
                    out += String.fromCharCode(ch); <span class="comment">// '\'</span>
                    tokPos += <span class="number">1</span>;
                }
            }
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-102">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-102">&#182;</a>
              </div>
              <p>Used to signal to callers of <code>readWord1</code> whether the word
contained any escape sequences. This is needed because words with
escape sequences must not be interpreted as keywords.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> containsEsc;</pre></div></div>
            
        </li>
        
        
        <li id="section-103">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-103">&#182;</a>
              </div>
              <p>Read an identifier, and return it as a string. Sets <code>containsEsc</code>
to whether the word contained a &#39;\u&#39; escape.</p>
<p>Only builds up the word character-by-character when it actually
containeds an escape, as a micro-optimization.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        readWord1 = <span class="keyword">function</span>() {
            containsEsc = <span class="literal">false</span>;
            <span class="keyword">var</span> word, first = <span class="literal">true</span>, start = tokPos;
            <span class="keyword">while</span> (<span class="literal">true</span>) {
                <span class="keyword">var</span> ch = input.charCodeAt(tokPos);
                <span class="keyword">if</span> (isIdentifierChar(ch)) {
                    <span class="keyword">if</span> (containsEsc) { word += input.charAt(tokPos); }
                    tokPos += <span class="number">1</span>;
                } <span class="keyword">else</span> <span class="keyword">if</span> (ch === <span class="number">92</span>) { <span class="comment">// "\"</span>
                    <span class="keyword">if</span> (!containsEsc) { word = input.slice(start, tokPos); }
                    containsEsc = <span class="literal">true</span>;
                    tokPos += <span class="number">1</span>;
                    <span class="keyword">if</span> (input.charCodeAt(tokPos) !== <span class="number">117</span>) { <span class="comment">// "u"</span>
                        raise(tokPos, <span class="string">"Expecting Unicode escape sequence \\uXXXX"</span>);
                    }
                    tokPos += <span class="number">1</span>;
                    <span class="keyword">var</span> esc = readHexChar(<span class="number">4</span>);
                    <span class="keyword">var</span> escStr = String.fromCharCode(esc);
                    <span class="keyword">if</span> (!escStr) {raise(tokPos - <span class="number">1</span>, <span class="string">"Invalid Unicode escape"</span>);}
                    <span class="keyword">if</span> (!(first ? isIdentifierStart(esc) : isIdentifierChar(esc))) {
                        raise(tokPos - <span class="number">4</span>, <span class="string">"Invalid Unicode escape"</span>);
                    }
                    word += escStr;
                } <span class="keyword">else</span> {
                    <span class="keyword">break</span>;
                }
                first = <span class="literal">false</span>;
            }
            <span class="keyword">return</span> containsEsc ? word : input.slice(start, tokPos);
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-104">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-104">&#182;</a>
              </div>
              <p>Read an identifier or keyword token. Will check for reserved
words when necessary.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        readWord = <span class="keyword">function</span>() {
            <span class="keyword">var</span> word = readWord1();
            <span class="keyword">var</span> type = _name;
            <span class="keyword">if</span> (!containsEsc) {
                <span class="keyword">if</span> (isKeyword(word)) { type = keywordTypes[word]; }
                <span class="keyword">else</span> <span class="keyword">if</span> (options.forbidReserved &amp;&amp;
                         (options.ecmaVersion === <span class="number">3</span> ? isReservedWord3 : isReservedWord5)(word) ||
                         strict &amp;&amp; isStrictReservedWord(word)) {
                    raise(tokStart, <span class="string">"The keyword '"</span> + word + <span class="string">"' is reserved"</span>);
                }
            }
            <span class="keyword">return</span> finishToken(type, word);
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-105">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-105">&#182;</a>
              </div>
              <h2>Environments</h2>
<p>Environments track global and local variable definitions
as we parse the <code>asm.js</code> module source.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> Env = <span class="keyword">function</span>() {</pre></div></div>
            
        </li>
        
        
        <li id="section-106">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-106">&#182;</a>
              </div>
              <p>Internally we use an object for a quick-and-dirty hashtable.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">this</span>._map = Object.create(<span class="literal">null</span>);
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-107">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-107">&#182;</a>
              </div>
              <p>Lookup an identifier in the environment.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        Env.prototype.lookup = <span class="keyword">function</span>(x) {</pre></div></div>
            
        </li>
        
        
        <li id="section-108">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-108">&#182;</a>
              </div>
              <p>Prefix the identifier to avoid conflicts with built-in
properties.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">return</span> <span class="keyword">this</span>._map[<span class="string">'$'</span>+x] || <span class="literal">null</span>;
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-109">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-109">&#182;</a>
              </div>
              <p>Bind a new identifier <code>x</code> to binding <code>t</code> in this environment.
If something goes wrong, use <code>loc</code> in the error message.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        Env.prototype.bind = <span class="keyword">function</span>(x, t, loc) {
            <span class="keyword">if</span> (x === <span class="string">'arguments'</span> || x === <span class="string">'eval'</span>) {
                raise(loc || tokStart, <span class="string">"illegal binding for '"</span>  + x + <span class="string">"'"</span>);
            }
            x = <span class="string">'$'</span> + x;
            <span class="keyword">if</span> (Object.prototype.hasOwnProperty.call(<span class="keyword">this</span>._map, x)) {
                raise(loc || tokStart, <span class="string">"duplicate binding for '"</span> + x + <span class="string">"'"</span>);
            }
            <span class="keyword">this</span>._map[x] = t;
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-110">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-110">&#182;</a>
              </div>
              <h2>Bindings</h2>
<p>Environments map identifiers to &quot;bindings&quot;; these are also each
parser production returns.  The represent runtime values (or
the means to access them): global variables, local variables,
compiler temporaries (the results of expression evaluation),
particular lvals (ArrayBufferView or function table objects),
or constants.</p>
<p>Bindings contain an <code>unEx</code> method to turn them into LLVM values
(registers, memory locations, constants) as well as to convert
them for use in expression statements (<code>unNx</code>) and conditionals
(<code>unCx</code>).  Terminology based on chapter 7 of Andrew Appel&#39;s
&quot;Modern Compiler Implementation in <em>__</em>&quot; series.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="comment">/* XXX we'll add unEx/unNx/unCx when we start codegen XXX */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-111">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-111">&#182;</a>
              </div>
              <p>We will need a unique symbol source for bindings.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> gensym = (<span class="keyword">function</span>() {
            <span class="keyword">var</span> cnt = <span class="number">0</span>;
            <span class="keyword">return</span> <span class="keyword">function</span>(prefix, base) {
                prefix = prefix || <span class="string">'%'</span>;
                base = base || <span class="string">'tmp'</span>;
                cnt += <span class="number">1</span>;
                <span class="keyword">return</span> prefix + base + cnt;
            };
        })();</pre></div></div>
            
        </li>
        
        
        <li id="section-112">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-112">&#182;</a>
              </div>
              <p>Global environments map to a type as well as a mutability boolean.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> GlobalBinding = <span class="keyword">function</span>(type, mutable) {
            <span class="keyword">this</span>.type = type;
            <span class="keyword">this</span>.mutable = !!mutable;
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-113">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-113">&#182;</a>
              </div>
              <p>Local environments map to a type and a local temporary.
(This isn&#39;t quite right for compilation; local variables
are mutable so we&#39;ll either need a map of temps as we
do SSA conversion, or else the temp should point to
alloca&#39;ed memory.)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> LocalBinding = <span class="keyword">function</span>(type, temp) {
            <span class="keyword">this</span>.type = type;
            <span class="keyword">this</span>.temp = temp || gensym();
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-114">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-114">&#182;</a>
              </div>
              <p>Temporary values are a type and a local temporary.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> TempBinding = <span class="keyword">function</span>(type, temp) {
            <span class="keyword">this</span>.type = type;
            <span class="keyword">this</span>.temp = temp || gensym();
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-115">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-115">&#182;</a>
              </div>
              <p>View references can be assigned to.  They have a type, and
a local temporary, but the temporary is a pointer (not the
value itself).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> ViewBinding = <span class="keyword">function</span>(type, temp) {
            <span class="keyword">this</span>.type = type;
            <span class="keyword">this</span>.temp = temp || gensym();
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-116">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-116">&#182;</a>
              </div>
              <p>Function table references propagate some type information
so that we can infer the type before seeing the declaration.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> TableBinding = <span class="keyword">function</span>(base, index, temp) {
            <span class="keyword">this</span>.base = base;
            <span class="keyword">this</span>.index = index;
            <span class="keyword">this</span>.type = base.type;
            <span class="keyword">this</span>.temp = temp || gensym();
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-117">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-117">&#182;</a>
              </div>
              <p>Constants are a type and a value.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> ConstantBinding = <span class="keyword">function</span>(type, value) {
            <span class="keyword">this</span>.type = type;
            <span class="keyword">this</span>.value = value;
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-118">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-118">&#182;</a>
              </div>
              <p>Sets the type field for a <code>ConstantBinding</code>
based on the value field, according to the rules for
NumericLiteral.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        ConstantBinding.prototype.setIntType = <span class="keyword">function</span>() {
            <span class="keyword">var</span> value = <span class="keyword">this</span>.value;
            <span class="keyword">if</span> (value &gt;= Types.Signed.min &amp;&amp;
                value &lt;= Types.Signed.max) {
                <span class="keyword">this</span>.type = Types.Signed;
            } <span class="keyword">else</span> <span class="keyword">if</span> (value &gt;= Types.Fixnum.min &amp;&amp;
                       value &lt;= Types.Fixnum.max) {
                <span class="keyword">this</span>.type = Types.Fixnum;
            } <span class="keyword">else</span> <span class="keyword">if</span> (value &gt;= Types.Unsigned.min &amp;&amp;
                       value &lt;= Types.Unsigned.max) {
                <span class="keyword">this</span>.type = Types.Unsigned;
            } <span class="keyword">else</span> {
                <span class="keyword">this</span>.type = <span class="literal">null</span>; <span class="comment">// caller must raise()</span>
            }
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-119">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-119">&#182;</a>
              </div>
              <p>Negate the value stored in a <code>ConstantBinding</code>, adjusting its
type as necessary.  Used to finesse unary negation of literals.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        ConstantBinding.prototype.negate = <span class="keyword">function</span>() {
            <span class="keyword">this</span>.value = -<span class="keyword">this</span>.value;
            <span class="keyword">if</span> (<span class="keyword">this</span>.type !== Types.Double) {
                <span class="keyword">this</span>.setIntType();
            }
            <span class="keyword">return</span> <span class="keyword">this</span>;
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-120">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-120">&#182;</a>
              </div>
              <h2>Parser</h2>
<p>A recursive descent parser operates by defining functions for all
syntactic elements, and recursively calling those, each function
advancing the input stream and returning an AST node. Precedence
of constructs (for example, the fact that <code>!x[1]</code> means <code>!(x[1])</code>
instead of <code>(!x)[1]</code> is handled by the fact that the parser
function that parses unary prefix operators is called first, and
in turn calls the function that parses <code>[]</code> subscripts  that
way, it&#39;ll receive the node for <code>x[1]</code> already parsed, and wraps
<em>that</em> in the unary operator node.</p>
<p>Following acorn, we use an <a href="http://en.wikipedia.org/wiki/Operator-precedence_parser">operator precedence
parser</a> to handle binary operator precedence, because
it is much more compact than using the technique outlined
above, which uses different, nesting functions to specify
precedence, for all of the ten binary precedence levels
that JavaScript defines.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> parseTopLevel; <span class="comment">// forward declaration</span></pre></div></div>
            
        </li>
        
        
        <li id="section-121">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-121">&#182;</a>
              </div>
              <p>As we parse, there will always be an active module.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> module;</pre></div></div>
            
        </li>
        
        
        <li id="section-122">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-122">&#182;</a>
              </div>
              <p>The main exported interface.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">this</span>.parse = <span class="keyword">function</span>(inpt, opts) {
            input = String(inpt); inputLen = input.length;
            setOptions(opts);
            initTokenState();
            module = <span class="literal">null</span>;
            <span class="keyword">return</span> parseTopLevel();
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-123">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-123">&#182;</a>
              </div>
              <h3>Parser utilities</h3>
<p>Raise an unexpected token error.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> unexpected = <span class="keyword">function</span>() {
            raise(tokStart, <span class="string">"Unexpected token"</span>);
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-124">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-124">&#182;</a>
              </div>
              <p>Continue to the next token.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> next = <span class="keyword">function</span>() {
            lastStart = tokStart;
            lastEnd = tokEnd;
            lastEndLoc = tokEndLoc;
            readToken();
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-125">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-125">&#182;</a>
              </div>
              <p>Predicate that tests whether the next token is of the given
type, and if yes, consumes it as a side effect.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> eat = <span class="keyword">function</span>(type) {
            <span class="keyword">if</span> (tokType === type) {
                next();
                <span class="keyword">return</span> <span class="literal">true</span>;
            }
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-126">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-126">&#182;</a>
              </div>
              <p>Test whether a semicolon can be inserted at the current position.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> canInsertSemicolon = <span class="keyword">function</span>() {
            <span class="keyword">return</span> !options.strictSemicolons &amp;&amp;
                (tokType === _eof || tokType === _braceR ||
                 newline.test(input.slice(lastEnd, tokStart)));
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-127">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-127">&#182;</a>
              </div>
              <p>Consume a semicolon, or, failing that, see if we are allowed to
pretend that there is a semicolon at this position.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> semicolon = <span class="keyword">function</span>() {
            <span class="keyword">if</span> (!eat(_semi) &amp;&amp; !canInsertSemicolon()) { unexpected(); }
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-128">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-128">&#182;</a>
              </div>
              <p>Expect a token of a given type. If found, consume it, otherwise,
raise an unexpected token error.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> expect = <span class="keyword">function</span>(type) {
            <span class="keyword">if</span> (tokType === type) { next(); }
            <span class="keyword">else</span> { unexpected(); }
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-129">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-129">&#182;</a>
              </div>
              <p>Expect a _name token matching the given identifier.  If found,
consume it, otherwise raise an error.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> expectName = <span class="keyword">function</span>(value, defaultValue) {
            <span class="keyword">if</span> (tokType !== _name || tokVal !== value) {
                raise(<span class="string">"expected "</span> + (value || defaultValue));
            } <span class="keyword">else</span> { next(); }
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-130">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-130">&#182;</a>
              </div>
              <p>Restore old token position, prior to reparsing.
This lets us implement &gt;1 token lookahead, which is needed
in a few places in the grammar (search for uses of backtrack()
to find them).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> backtrack = <span class="keyword">function</span>(oldPos, retval) {</pre></div></div>
            
        </li>
        
        
        <li id="section-131">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-131">&#182;</a>
              </div>
              <p>Restore old position.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            tokPos = oldPos;</pre></div></div>
            
        </li>
        
        
        <li id="section-132">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-132">&#182;</a>
              </div>
              <p>Adjust the line counter.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">while</span> (tokPos &lt; tokLineStart) {
                tokLineStart =
                    input.lastIndexOf(<span class="string">"\n"</span>, tokLineStart - <span class="number">2</span>) + <span class="number">1</span>;
                tokCurLine -= <span class="number">1</span>;
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-133">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-133">&#182;</a>
              </div>
              <p>Re-read the token at that position.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            skipSpace();
            readToken();</pre></div></div>
            
        </li>
        
        
        <li id="section-134">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-134">&#182;</a>
              </div>
              <p>Optionally, return a value (useful for <code>return backtrack(...)</code>
statements).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">return</span> retval;
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-135">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-135">&#182;</a>
              </div>
              <p>Raise with a nice error message if the given type isn&#39;t
a subtype of that provided.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> typecheck = <span class="keyword">function</span>(actual, should, message, pos) {
            <span class="keyword">if</span> (actual.isSubtypeOf(should)) { <span class="keyword">return</span> actual; }
            <span class="keyword">if</span> (actual === Types.ForwardReference) {
                raise(pos || tokStart, <span class="string">"unknown identifier"</span>);
            }
            raise(pos || tokStart, <span class="string">"validation error ("</span>+message+<span class="string">"): "</span> +
                  <span class="string">"should be "</span> + (should ? should.toString() : <span class="string">'?'</span>) +
                  <span class="string">", but was "</span> + (actual ? actual.toString() : <span class="string">'?'</span>));
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-136">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-136">&#182;</a>
              </div>
              <p>Raise with a nice error message if the given binding is
a forward reference.  Since <code>ForwardReference</code> is only used
in narrow circumstances when parsing a call to a local function
or dereference of a function table, we can get better error
messages by aggressively asserting that a given binding should
not be a forward reference.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> defcheck = <span class="keyword">function</span>(binding, message) {
            <span class="keyword">if</span> (binding.type !== Types.ForwardReference) { <span class="keyword">return</span> binding; }
            raise(binding.pos || tokStart,
                  (binding.id ? (<span class="string">"'"</span>+binding.id+<span class="string">"' is "</span>) : <span class="string">""</span>) +<span class="string">"undefined,"</span>+
                  <span class="string">" or an invalid reference to future function or function"</span>+
                  <span class="string">" table"</span> + (message ? (<span class="string">" ("</span>+message+<span class="string">")"</span>) : <span class="string">""</span>));
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-137">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-137">&#182;</a>
              </div>
              <p>Merge types.  This is used for single-forward-pass compilation:
when we first see a reference to a function (or its return type)
infer an appropriate type from its use site.  At subsequent
references we will continue to merge inferred types.  Raise
an error if some use site requires a type inconsistent with
the inferred type at that point.  See
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=864600">https://bugzilla.mozilla.org/show_bug.cgi?id=864600</a> for
more discussion of the single-forward-pass strategy.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> mergeTypes = <span class="keyword">function</span>(prevType, newType, pos) {
            <span class="keyword">if</span> (prevType===Types.ForwardReference ||
                newType.isSubtypeOf(prevType)) {
                <span class="keyword">return</span> newType;
            }
            raise(pos || tokStart,
                  <span class="string">"Inconsistent type (was "</span> + prevType.toString() +
                  <span class="string">", now "</span> + newType.toString()+<span class="string">")"</span>);
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-138">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-138">&#182;</a>
              </div>
              <h3>Literal parsing</h3>
<p>Parse the next token as an identifier. If <code>liberal</code> is true (used
when parsing properties), it will also convert keywords into
identifiers.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> parseIdent = <span class="keyword">function</span>(liberal) {
            <span class="keyword">var</span> name = (tokType === _name) ? tokVal :
                (liberal &amp;&amp; (!options.forbidReserved) &amp;&amp; tokType.keyword) ||
                unexpected();
            next();
            <span class="keyword">return</span> name;
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-139">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-139">&#182;</a>
              </div>
              <p>Look up an identifier in the local and global environments.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> moduleLookup = <span class="keyword">function</span>(id) {
            <span class="keyword">if</span> (module.func) {
                <span class="keyword">var</span> binding = module.func.env.lookup(id);
                <span class="keyword">if</span> (binding !== <span class="literal">null</span>) { <span class="keyword">return</span> binding; }
            }
            <span class="keyword">return</span> module.env.lookup(id);
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-140">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-140">&#182;</a>
              </div>
              <p>Parse a numeric literal, returning a type and a value.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> parseNumericLiteral = <span class="keyword">function</span>() {
            <span class="keyword">var</span> numStart = tokStart;
            <span class="keyword">var</span> negate = (tokType===_plusmin &amp;&amp; tokVal===<span class="string">'-'</span>);
            <span class="keyword">if</span> (negate) { next(); }
            <span class="keyword">var</span> result = ConstantBinding.New(Types.Double, tokVal);
            <span class="keyword">if</span> (tokType === _num) {
                result.setIntType();
                <span class="keyword">if</span> (result.type===<span class="literal">null</span>) {
                    raise(numStart, <span class="string">"Invalid integer literal"</span>);
                }
            } <span class="keyword">else</span> <span class="keyword">if</span> (tokType !== _dotnum) {
                raise(numStart, <span class="string">"expected a numeric literal"</span>);
            }
            next();
            <span class="keyword">if</span> (negate) { result.negate(); }
            <span class="keyword">return</span> result;
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-141">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-141">&#182;</a>
              </div>
              <h3>Expression parsing</h3>
<p>These nest, from the most general expression type at the top to
&#39;atomic&#39;, nondivisible expression types at the bottom. Most of
the functions will simply let the function(s) below them parse,
and, <em>if</em> the syntactic construct they handle is present, wrap
the AST node that the inner parser gave them in another node.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> parseExpression; <span class="comment">// forward declaration</span></pre></div></div>
            
        </li>
        
        
        <li id="section-142">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-142">&#182;</a>
              </div>
              <p>Parses a comma-separated list of expressions, and returns them as
an array. <code>close</code> is the token type that ends the list, and
<code>allowEmpty</code> can be turned on to allow subsequent commas with
nothing in between them to be parsed as <code>null</code> (which is needed
for array literals).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> parseExprList = <span class="keyword">function</span>(close, allowTrailingComma, allowEmpty) {
            <span class="keyword">var</span> elts = [], first = <span class="literal">true</span>;
            <span class="keyword">while</span> (!eat(close)) {
                <span class="keyword">if</span> (first) { first = <span class="literal">false</span>; }
                <span class="keyword">else</span> {
                    expect(_comma);
                    <span class="keyword">if</span> (allowTrailingComma &amp;&amp; options.allowTrailingCommas &amp;&amp;
                        eat(close)) {
                        <span class="keyword">break</span>;
                    }
                }

                <span class="keyword">if</span> (allowEmpty &amp;&amp; tokType === _comma) { elts.push(<span class="literal">null</span>); }
                <span class="keyword">else</span> { elts.push(parseExpression(<span class="literal">true</span>)); }
            }
            <span class="keyword">return</span> elts;
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-143">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-143">&#182;</a>
              </div>
              <p>Parse an atomic expression  either a single token that is an
expression, an expression started by a keyword like <code>function</code> or
<code>new</code>, or an expression wrapped in punctuation like <code>()</code>, <code>[]</code>,
or <code>{}</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> parseExprAtom = <span class="keyword">function</span>() {
            <span class="keyword">if</span> (tokType === _name) {
                <span class="keyword">var</span> id = parseIdent();
                <span class="keyword">var</span> binding = moduleLookup(id);
                <span class="keyword">if</span> (binding===<span class="literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-144">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-144">&#182;</a>
              </div>
              <p>Let&#39;s put a stub global binding in place; maybe this
is a reference to a function or function table type
which has not yet been defined.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    binding = GlobalBinding.New(Types.ForwardReference, <span class="literal">false</span>);
                    binding.pending = <span class="literal">true</span>;
                    binding.id = id; <span class="comment">// for better error messages</span>
                    binding.pos = lastStart; <span class="comment">// ditto</span>
                    module.env.bind(id, binding, lastStart);
                }
                <span class="keyword">return</span> binding;

            } <span class="keyword">else</span> <span class="keyword">if</span> (tokType === _num || tokType === _dotnum) {
                <span class="keyword">return</span> parseNumericLiteral();

            } <span class="keyword">else</span> <span class="keyword">if</span> (tokType === _parenL) {
                next();
                <span class="keyword">var</span> val = parseExpression();
                expect(_parenR);
                <span class="keyword">return</span> val;

            } <span class="keyword">else</span> {
                unexpected();
            }
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-145">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-145">&#182;</a>
              </div>
              <p>Parse expression inside <code>[]</code>-subscript.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> parseBracketExpression = <span class="keyword">function</span>(base) {
            <span class="keyword">var</span> startPos = tokStart;
            <span class="keyword">var</span> property = parseExpression();</pre></div></div>
            
        </li>
        
        
        <li id="section-146">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-146">&#182;</a>
              </div>
              <p>This will be a MemberExpression (or a CallExpression
through function table).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">if</span> (base.type.arrayBufferView) {
                defcheck(property);</pre></div></div>
            
        </li>
        
        
        <li id="section-147">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-147">&#182;</a>
              </div>
              <p><code>MemberExpression := x:Identifier[n:NumericLiteral]</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="keyword">if</span> (ConstantBinding.hasInstance(property)) {
                    <span class="keyword">if</span> (property.type !== Types.Fixnum &amp;&amp;
                        property.type !== Types.Unsigned) {
                        raise(startPos, <span class="string">"view offset out of bounds"</span>);
                    }
                    <span class="keyword">return</span> ViewBinding.New(base.type.base);
                }</pre></div></div>
            
        </li>
        
        
        <li id="section-148">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-148">&#182;</a>
              </div>
              <p><code>MemberExpression := x:Identifier[expr:Expression]</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="keyword">if</span> (base.type.bytes===<span class="number">1</span> &amp;&amp; base.type.base===Types.Intish) {
                    typecheck(property.type, Types.Int,
                              <span class="string">"offset on 1-byte view"</span>, startPos);
                    <span class="keyword">return</span> ViewBinding.New(base.type.base);
                }</pre></div></div>
            
        </li>
        
        
        <li id="section-149">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-149">&#182;</a>
              </div>
              <p><code>MemberExpression := x:Identifier[expr:Expression &gt;&gt; n:NumericLiteral]</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="keyword">if</span> (property.shifty &amp;&amp; powerOf2(base.type.bytes)) {
                    typecheck(property.shifty.type, Types.Intish,
                              <span class="string">"view offset"</span>, startPos);
                    <span class="keyword">if</span> (property.shiftAmount !== ceilLog2(base.type.bytes)) {
                        raise(startPos, <span class="string">"shift amount should be "</span>+
                              ceilLog2(base.type.bytes));
                    }
                    <span class="keyword">return</span> ViewBinding.New(base.type.base);
                }
                raise(startPos, <span class="string">"bad ArrayBufferView member expression"</span>);
            } <span class="keyword">else</span> <span class="keyword">if</span> (property.andy) {</pre></div></div>
            
        </li>
        
        
        <li id="section-150">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-150">&#182;</a>
              </div>
              <p>Try to parse as a function table lookup:
<code>x:Identifier[index:Expression &amp; n:NumericLiteral](arg:Expression,...)</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="keyword">return</span> TableBinding.New(base, property);
            } <span class="keyword">else</span> {
                raise(startPos, <span class="string">"bad member expression"</span>);
            }
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-151">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-151">&#182;</a>
              </div>
              <p>Parse call, dot, and <code>[]</code>-subscript expressions.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> parseSubscripts = <span class="keyword">function</span>(base, plusCoerced) {
            <span class="keyword">if</span> (eat(_dot)) {
                raise(lastStart, <span class="string">"operator not allowed: ."</span>);
            } <span class="keyword">else</span> <span class="keyword">if</span> (eat(_bracketL)) {
                base = parseBracketExpression(base);
                expect(_bracketR);
                <span class="keyword">return</span> parseSubscripts(base, plusCoerced);
            } <span class="keyword">else</span> <span class="keyword">if</span> (eat(_parenL)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-152">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-152">&#182;</a>
              </div>
              <p>Parse a call expression.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="keyword">var</span> startPos = lastStart;
                <span class="keyword">var</span> callArguments = parseExprList(_parenR, <span class="literal">false</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-153">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-153">&#182;</a>
              </div>
              <p>Type check the call based on the argument types.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="keyword">var</span> binding, ty;
                <span class="keyword">var</span> argTypes = callArguments.map(<span class="keyword">function</span>(b){
                    <span class="keyword">return</span> defcheck(b).type;
                });</pre></div></div>
            
        </li>
        
        
        <li id="section-154">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-154">&#182;</a>
              </div>
              <p>If this is a forward reference to a future function,
infer the function type based on &#39;plusCoerced&#39; (the
surrounding context) and the argument types.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="keyword">var</span> makeFunctionTypeFromContext = <span class="keyword">function</span>() {
                    <span class="keyword">return</span> Types.Arrow(argTypes.map(<span class="keyword">function</span>(ty) {</pre></div></div>
            
        </li>
        
        
        <li id="section-155">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-155">&#182;</a>
              </div>
              <p>All argument types must be either &#39;double&#39; or &#39;int&#39;.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                        <span class="keyword">if</span> (ty.isSubtypeOf(Types.Double)) {
                            <span class="keyword">return</span> Types.Double;
                        } <span class="keyword">else</span> <span class="keyword">if</span> (ty.isSubtypeOf(Types.Int)) {
                            <span class="keyword">return</span> Types.Int;
                        } <span class="keyword">else</span> {
                            raise(startPos, <span class="string">"function arguments must be "</span>+
                                  <span class="string">"coerced to either double or int"</span>);
                        }</pre></div></div>
            
        </li>
        
        
        <li id="section-156">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-156">&#182;</a>
              </div>
              <p>Return type is either &#39;doublish&#39; or &#39;intish&#39;</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    }), plusCoerced ? Types.Doublish : Types.Intish);
                };
                <span class="keyword">if</span> (TableBinding.hasInstance(base)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-157">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-157">&#182;</a>
              </div>
              <p>Handle an indirect invocation through a function table.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    <span class="keyword">if</span> (!powerOf2(base.index.andAmount+<span class="number">1</span>)) {
                        raise(startPos,
                              <span class="string">"function table size must be a power of 2"</span>);
                    }
                    <span class="keyword">if</span> (base.base.type === Types.ForwardReference) {
                        base.base.type =
                            Types.Table(makeFunctionTypeFromContext(),
                                        base.index.andAmount+<span class="number">1</span>);
                    }
                    <span class="keyword">if</span> (!base.base.type.table) {
                        raise(startPos, <span class="string">"base should be function table"</span>);
                    }
                    <span class="keyword">if</span> (base.base.type.size !== (base.index.andAmount+<span class="number">1</span>)) {
                        raise(startPos, <span class="string">"function table size mismatch"</span>);
                    }
                    ty = base.base.type.base.apply(argTypes);
                    <span class="keyword">if</span> (ty===<span class="literal">null</span>) {
                        raise(startPos, <span class="string">"call argument mismatch; wants "</span>+
                              base.type.base.toString());
                    }
                    binding = TempBinding.New(ty);
                } <span class="keyword">else</span> <span class="keyword">if</span> (base.type===Types.Function) {</pre></div></div>
            
        </li>
        
        
        <li id="section-158">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-158">&#182;</a>
              </div>
              <p>Handle foreign function invocation.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    argTypes.forEach(<span class="keyword">function</span>(type, i) {
                        <span class="keyword">var</span> msg = <span class="string">"argument "</span>+i+<span class="string">" to foreign function"</span>;
                        typecheck(type, Types.Extern, msg, startPos);
                    });
                    binding = TempBinding.New(Types.Unknown);
                } <span class="keyword">else</span> <span class="keyword">if</span> (base.type.arrow || base.type.functiontypes ||
                           base.type === Types.ForwardReference) {</pre></div></div>
            
        </li>
        
        
        <li id="section-159">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-159">&#182;</a>
              </div>
              <p>Handle direct invocation of local function.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    <span class="keyword">if</span> (base.type === Types.ForwardReference) {
                        base.type = makeFunctionTypeFromContext();
                    }
                    ty = base.type.apply(argTypes);
                    <span class="keyword">if</span> (ty===<span class="literal">null</span>) {
                        raise(startPos, <span class="string">"call argument mismatch; wants "</span>+
                              base.type.toString());
                    }
                    binding = TempBinding.New(ty);
                } <span class="keyword">else</span> {
                    raise(startPos, <span class="string">"bad call expression"</span>);
                }
                <span class="keyword">return</span> parseSubscripts(binding, plusCoerced);
            } <span class="keyword">else</span> { <span class="keyword">return</span> base; }
        };

        <span class="keyword">var</span> parseExprSubscripts = <span class="keyword">function</span>(plusCoerced) {
            <span class="keyword">var</span> b = parseSubscripts(parseExprAtom(), plusCoerced);
            <span class="keyword">if</span> (TableBinding.hasInstance(b)) {
                raise(tokStart, <span class="string">"incomplete function table lookup"</span>);
            }
            <span class="keyword">return</span> b;
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-160">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-160">&#182;</a>
              </div>
              <p>Parse unary operators, both prefix and postfix.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> parseMaybeUnary = <span class="keyword">function</span>(plusCoerced) {
            <span class="keyword">var</span> node;
            <span class="keyword">if</span> (tokType.prefix) {
                <span class="keyword">var</span> opPos = tokStart;
                <span class="keyword">var</span> update = tokType.isUpdate; <span class="comment">// for ++/--</span>
                <span class="keyword">var</span> operator = tokVal;
                <span class="keyword">var</span> ty = Types.unary[operator];
                <span class="keyword">if</span> (!ty) {
                    raise(opPos, operator+<span class="string">" not allowed"</span>);
                }
                console.assert(!update);
                next();
                <span class="keyword">var</span> argument = defcheck(parseMaybeUnary(operator===<span class="string">'+'</span>));</pre></div></div>
            
        </li>
        
        
        <li id="section-161">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-161">&#182;</a>
              </div>
              <p>Special case the negation of a constant.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="keyword">if</span> (ConstantBinding.hasInstance(argument) &amp;&amp; operator===<span class="string">'-'</span>) {
                    <span class="keyword">return</span> argument.negate();
                }
                ty = ty.apply([argument.type]);
                <span class="keyword">if</span> (ty===<span class="literal">null</span>) {
                    raise(opPos, <span class="string">"unary "</span>+operator+<span class="string">" fails to validate: "</span>+
                          operator+<span class="string">" "</span>+argument.type.toString());
                }
                <span class="keyword">return</span> TempBinding.New(ty);
            }
            <span class="keyword">var</span> expr = parseExprSubscripts(plusCoerced);
            <span class="keyword">if</span> (tokType.postfix &amp;&amp; !canInsertSemicolon()) {
                raise(tokStart, <span class="string">"postfix operators not allowed"</span>);
            }
            <span class="keyword">return</span> expr;
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-162">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-162">&#182;</a>
              </div>
              <p>Start the precedence parser.</p>
<p>Parse binary operators with the operator precedence parsing
algorithm. <code>left</code> is the left-hand side of the operator.
<code>minPrec</code> provides context that allows the function to stop and
defer further parser to one of its callers when it encounters an
operator that has a lower precedence than the set it is parsing.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> parseExprOp = <span class="keyword">function</span>(left, minPrec) {
            <span class="keyword">var</span> TWO_TO_THE_TWENTY = <span class="number">0x100000</span>;
            <span class="keyword">var</span> prec = tokType.binop;
            console.assert(prec !== <span class="literal">null</span>, tokType);
            <span class="keyword">if</span> (prec !== <span class="literal">undefined</span>) {
                <span class="keyword">if</span> (prec &gt; minPrec) {
                    <span class="keyword">var</span> additiveChain = <span class="number">0</span>;
                    <span class="keyword">var</span> opPos = tokStart;
                    <span class="keyword">var</span> operator = tokVal;
                    <span class="keyword">var</span> ty = Types.binary[operator];
                    <span class="keyword">if</span> (!ty) {
                        raise(opPos, operator+<span class="string">" not allowed"</span>);
                    }
                    next();
                    <span class="keyword">var</span> right = parseExprOp(parseMaybeUnary(<span class="literal">false</span>), prec);
                    defcheck(left); defcheck(right);
                    ty = ty.apply([left.type, right.type]);
                    <span class="keyword">if</span> (ty===<span class="literal">null</span> &amp;&amp; (operator===<span class="string">'+'</span> || operator===<span class="string">'-'</span>)) {
                        <span class="comment">/* Special validation for "AdditiveExpression" */</span>
                        <span class="keyword">if</span> ((left.additiveChain ||
                             left.type.isSubtypeOf(Types.Int)) &amp;&amp;
                            right.type.isSubtypeOf(Types.Int)) {
                            ty = Types.Intish;
                            additiveChain = (left.additiveChain||<span class="number">1</span>) + <span class="number">1</span>;
                            <span class="keyword">if</span> (additiveChain &gt; TWO_TO_THE_TWENTY) { <span class="comment">// 2^20</span>
                                raise(opPos, <span class="string">"too many additive operations"</span>);
                            }
                        }
                    }
                    <span class="keyword">if</span> (ty===<span class="literal">null</span> &amp;&amp; operator===<span class="string">'*'</span>) {
                        <span class="comment">/* Special validation for MultiplicativeExpression */</span>
                        <span class="keyword">var</span> isGoodLiteral = <span class="keyword">function</span>(b) {
                            <span class="keyword">return</span> ConstantBinding.hasInstance(b) &amp;&amp;
                                b.type !== Types.Double &amp;&amp;
                                (-TWO_TO_THE_TWENTY) &lt; b.value &amp;&amp;
                                b.value &lt; TWO_TO_THE_TWENTY;
                        };
                        <span class="keyword">if</span> ((isGoodLiteral(left) &amp;&amp;
                            right.type.isSubtypeOf(Types.Int)) ||
                            (isGoodLiteral(right) &amp;&amp;
                             left.type.isSubtypeOf(Types.Int))) {
                            ty = Types.Intish;
                        }
                    }
                    <span class="keyword">if</span> (ty===<span class="literal">null</span>) {
                        raise(opPos, <span class="string">"binary "</span>+operator+<span class="string">" fails to validate: "</span>+
                              left.type.toString() +
                              <span class="string">" "</span> + operator + <span class="string">" "</span> +
                              right.type.toString());
                    }
                    <span class="keyword">var</span> binding = TempBinding.New(ty);
                    <span class="keyword">if</span> (additiveChain) {
                        binding.additiveChain = additiveChain;
                    }
                    <span class="keyword">if</span> (ConstantBinding.hasInstance(right) &amp;&amp;
                        right.type !== Types.Double) {
                        <span class="keyword">if</span> (operator===<span class="string">'&gt;&gt;'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-163">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-163">&#182;</a>
              </div>
              <p>Record the pre-shift value and the shift amount,
for later use in <code>parseBracketExpression()</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                            binding.shifty = left;
                            binding.shiftAmount = right.value;
                        } <span class="keyword">else</span> <span class="keyword">if</span> (operator===<span class="string">'&amp;'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-164">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-164">&#182;</a>
              </div>
              <p>Record the rhs for later use in
<code>parseBracketExpression</code> (in case this is a
function table dereference).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                            binding.andy = <span class="literal">true</span>;
                            binding.andAmount = right.value;
                        }
                    }
                    <span class="keyword">return</span> parseExprOp(binding, minPrec);
                }
            }
            <span class="keyword">return</span> left;
        };

        <span class="keyword">var</span> parseExprOps = <span class="keyword">function</span>() {
            <span class="keyword">return</span> parseExprOp(parseMaybeUnary(<span class="literal">false</span>), -<span class="number">1</span>);
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-165">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-165">&#182;</a>
              </div>
              <p>Parse a ternary conditional (<code>?:</code>) operator.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> parseMaybeConditional = <span class="keyword">function</span>() {
            <span class="keyword">var</span> expr = parseExprOps();
            <span class="keyword">var</span> startPos = tokStart;
            <span class="keyword">if</span> (eat(_question)) {
                <span class="keyword">var</span> test = defcheck(expr);
                typecheck(test.type, Types.Int, <span class="string">"conditional test"</span>, startPos);
                <span class="keyword">var</span> consequent = parseExpression(<span class="literal">true</span>);
                expect(_colon);
                <span class="keyword">var</span> alternate = parseExpression(<span class="literal">true</span>);
                <span class="keyword">var</span> ty;
                <span class="keyword">if</span> (consequent.type.isSubtypeOf(Types.Int) &amp;&amp;
                    alternate.type.isSubtypeOf(Types.Int)) {
                    ty = Types.Int;
                } <span class="keyword">else</span> <span class="keyword">if</span> (consequent.type.isSubtypeOf(Types.Double) &amp;&amp;
                           alternate.type.isSubtypeOf(Types.Double)) {
                    ty = Types.Double;
                } <span class="keyword">else</span> {
                    raise(startPos, <span class="string">"validation error: "</span>+
                          test.type.toString() + <span class="string">" ? "</span> +
                          consequent.type.toString() + <span class="string">" : "</span> +
                          alternate.type.toString());
                }
                <span class="keyword">var</span> binding = TempBinding.New(ty);
                <span class="keyword">return</span> binding;
            }
            <span class="keyword">return</span> expr;
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-166">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-166">&#182;</a>
              </div>
              <p>Parse an assignment expression. This includes applications of
operators like <code>+=</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> parseMaybeAssign = <span class="keyword">function</span>() {
            <span class="keyword">var</span> left = parseMaybeConditional();
            <span class="keyword">if</span> (tokType.isAssign) {
                <span class="keyword">var</span> startPos = tokStart;
                <span class="keyword">var</span> operator = tokVal;
                <span class="keyword">if</span> (operator !== <span class="string">'='</span>) {
                    raise(startPos, <span class="string">"Operator disallowed: "</span>+operator);
                }
                next();
                <span class="keyword">var</span> right = parseMaybeAssign();</pre></div></div>
            
        </li>
        
        
        <li id="section-167">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-167">&#182;</a>
              </div>
              <p>Check that <code>left</code> is an lval.  First, let&#39;s check
the <code>x:Identifier = ...</code> case.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="keyword">if</span> (LocalBinding.hasInstance(left)) {
                    typecheck(right.type, left.type, <span class="string">"rhs of assignment"</span>,
                              startPos);
                } <span class="keyword">else</span> <span class="keyword">if</span> (GlobalBinding.hasInstance(left)) {
                    <span class="keyword">if</span> (!left.mutable) {
                        raise(startPos, (left.id ? <span class="string">"'"</span>+left.id+<span class="string">"' "</span>:<span class="string">""</span>) +
                              <span class="string">"not mutable or undefined"</span>);
                    }
                    typecheck(right.type, left.type, <span class="string">"rhs of assignment"</span>,
                              startPos);</pre></div></div>
            
        </li>
        
        
        <li id="section-168">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-168">&#182;</a>
              </div>
              <p>Now check <code>lhs:MemberExpression = rhs:AssignmentExpression</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                } <span class="keyword">else</span> <span class="keyword">if</span> (ViewBinding.hasInstance(left)) {
                    typecheck(right.type, left.type, <span class="string">"rhs of assignment"</span>,
                              startPos);
                } <span class="keyword">else</span> {
                    raise(startPos, <span class="string">"assignment to non-lval"</span>);
                }
                <span class="keyword">return</span>;
            }
            <span class="keyword">return</span> left;
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-169">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-169">&#182;</a>
              </div>
              <p>Parse a full expression. The arguments are used to forbid comma
sequences (in argument lists, array literals, or object literals)
or the <code>in</code> operator (in for loops initalization expressions).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        parseExpression = <span class="keyword">function</span>(noComma) {
            <span class="keyword">var</span> expr = parseMaybeAssign();
            <span class="keyword">if</span> (!noComma &amp;&amp; tokType === _comma) {
                <span class="keyword">var</span> expressions = [expr];
                <span class="keyword">while</span> (eat(_comma)) {
                    expressions.push(expr = parseMaybeAssign());
                }
            }
            <span class="keyword">return</span> expr;
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-170">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-170">&#182;</a>
              </div>
              <p>Used for constructs like <code>switch</code> and <code>if</code> that insist on
parentheses around their expression.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> parseParenExpression = <span class="keyword">function</span>() {
            expect(_parenL);
            <span class="keyword">var</span> val = parseExpression();
            expect(_parenR);
            <span class="keyword">return</span> val;
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-171">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-171">&#182;</a>
              </div>
              <h3>Statement parsing</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> loopLabel = {kind: <span class="string">"loop"</span>}, switchLabel = {kind: <span class="string">"switch"</span>};

        <span class="keyword">var</span> parseStatement, parseFor, parseBlock; <span class="comment">// forward declaration</span></pre></div></div>
            
        </li>
        
        
        <li id="section-172">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-172">&#182;</a>
              </div>
              <p>Parse a single statement.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        parseStatement = <span class="keyword">function</span>() {
            <span class="keyword">var</span> starttype = tokType;
            <span class="keyword">var</span> startPos = tokStart;</pre></div></div>
            
        </li>
        
        
        <li id="section-173">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-173">&#182;</a>
              </div>
              <p>Most types of statements are recognized by the keyword they
start with. Many are trivial to parse, some require a bit of
complexity.</p>
<h4>BreakStatement / ContinueStatement</h4>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">if</span> (starttype===_<span class="keyword">break</span> || starttype===_<span class="keyword">continue</span>) {
                next();
                <span class="keyword">var</span> isBreak = (starttype === _<span class="keyword">break</span>), label;
                <span class="keyword">if</span> (eat(_semi) || canInsertSemicolon()) { label = <span class="literal">null</span>; }
                <span class="keyword">else</span> <span class="keyword">if</span> (tokType !== _name) { unexpected(); }
                <span class="keyword">else</span> {
                    label = parseIdent();
                    semicolon();
                }</pre></div></div>
            
        </li>
        
        
        <li id="section-174">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-174">&#182;</a>
              </div>
              <p>Verify that there is an actual destination to break or
continue to.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="keyword">var</span> found = <span class="literal">false</span>;
                module.func.labels.forEach(<span class="keyword">function</span>(lab, i) {
                    <span class="keyword">if</span> (label === <span class="literal">null</span> || lab.name === label.name) {
                        <span class="keyword">if</span> (lab.kind !== <span class="literal">null</span> &amp;&amp; <span class="comment">// no 'continue' in switch</span>
                            (isBreak || lab.kind === <span class="string">"loop"</span>)) {
                            found = <span class="literal">true</span>;
                            <span class="comment">/* XXX break out of forEach */</span>
                        }
                        <span class="keyword">if</span> (label &amp;&amp; isBreak) { <span class="comment">// always 'break' if names match</span>
                            found = <span class="literal">true</span>;
                            <span class="comment">/* XXX break out of forEach */</span>
                        }
                    }
                });
                <span class="keyword">if</span> (!found) {
                    raise(startPos, <span class="string">"Unsyntactic "</span> + starttype.keyword);
                }
                <span class="keyword">return</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-175">
            <div class="annotation">
              
              <div class="pilwrap for-h4">
                <a class="pilcrow" href="#section-175">&#182;</a>
              </div>
              <h4>IterationStatement</h4>

            </div>
            
            <div class="content"><div class='highlight'><pre>            } <span class="keyword">else</span> <span class="keyword">if</span> (starttype===_<span class="keyword">while</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-176">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-176">&#182;</a>
              </div>
              <p>Parse a while loop.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                next();
                startPos = tokStart;
                <span class="keyword">var</span> whileTest = defcheck(parseParenExpression());
                typecheck(whileTest.type, Types.Int, <span class="string">"while loop condition"</span>,
                          startPos);
                module.func.labels.push(loopLabel);
                <span class="keyword">var</span> whileBody = parseStatement();
                module.func.labels.pop();
                <span class="keyword">return</span>;

            } <span class="keyword">else</span> <span class="keyword">if</span> (starttype===_<span class="keyword">do</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-177">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-177">&#182;</a>
              </div>
              <p>Parse a do-while loop.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                next();
                module.func.labels.push(loopLabel);
                <span class="keyword">var</span> doBody = parseStatement();
                module.func.labels.pop();
                expect(_<span class="keyword">while</span>);
                startPos = tokStart;
                <span class="keyword">var</span> doTest = defcheck(parseParenExpression());
                semicolon();
                typecheck(doTest.type, Types.Int, <span class="string">"do-while loop condition"</span>,
                          startPos);
                <span class="keyword">return</span>;

            } <span class="keyword">else</span> <span class="keyword">if</span> (starttype===_<span class="keyword">for</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-178">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-178">&#182;</a>
              </div>
              <p>Parse a for loop.</p>
<p>Disambiguating between a <code>for</code> and a <code>for</code>/<code>in</code> loop is
non-trivial. Luckily, <code>for</code>/<code>in</code> loops aren&#39;t allowed in
<code>asm.js</code>!</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                next();
                module.func.labels.push(loopLabel);
                expect(_parenL);
                <span class="keyword">if</span> (tokType === _semi) { <span class="keyword">return</span> parseFor(<span class="literal">null</span>); }
                <span class="keyword">var</span> init = defcheck(parseExpression(<span class="literal">false</span>));
                <span class="keyword">return</span> parseFor(init);</pre></div></div>
            
        </li>
        
        
        <li id="section-179">
            <div class="annotation">
              
              <div class="pilwrap for-h4">
                <a class="pilcrow" href="#section-179">&#182;</a>
              </div>
              <h4>IfStatement</h4>

            </div>
            
            <div class="content"><div class='highlight'><pre>            } <span class="keyword">else</span> <span class="keyword">if</span> (starttype===_<span class="keyword">if</span>) {
                next();
                startPos = tokStart;
                <span class="keyword">var</span> ifTest = defcheck(parseParenExpression());
                typecheck(ifTest.type, Types.Int, <span class="string">"if statement condition"</span>,
                          startPos);
                <span class="keyword">var</span> consequent = parseStatement();
                <span class="keyword">var</span> alternate = eat(_<span class="keyword">else</span>) ? parseStatement() : <span class="literal">null</span>;
                <span class="keyword">return</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-180">
            <div class="annotation">
              
              <div class="pilwrap for-h4">
                <a class="pilcrow" href="#section-180">&#182;</a>
              </div>
              <h4>ReturnStatement</h4>

            </div>
            
            <div class="content"><div class='highlight'><pre>            } <span class="keyword">else</span> <span class="keyword">if</span> (starttype===_<span class="keyword">return</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-181">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-181">&#182;</a>
              </div>
              <p>In <code>return</code> (and <code>break</code>/<code>continue</code>), the keywords with
optional arguments, we eagerly look for a semicolon or the
possibility to insert one.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="keyword">var</span> ty;
                next();
                startPos = tokStart;
                <span class="keyword">if</span> (eat(_semi) || canInsertSemicolon()) {
                    ty = Types.Void;
                } <span class="keyword">else</span> {
                    <span class="keyword">var</span> binding = defcheck(parseExpression()); semicolon();
                    ty = binding.type;
                }
                module.func.retType =
                    mergeTypes(module.func.retType, ty, startPos);
                <span class="keyword">return</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-182">
            <div class="annotation">
              
              <div class="pilwrap for-h4">
                <a class="pilcrow" href="#section-182">&#182;</a>
              </div>
              <h4>SwitchStatement</h4>

            </div>
            
            <div class="content"><div class='highlight'><pre>            } <span class="keyword">else</span> <span class="keyword">if</span> (starttype===_<span class="keyword">switch</span>) {
                next();
                startPos = tokStart;
                <span class="keyword">var</span> switchTest = defcheck(parseParenExpression());
                typecheck(switchTest, Types.Signed, <span class="string">"switch discriminant"</span>,
                          startPos);
                <span class="keyword">var</span> cases = [];
                expect(_braceL);
                module.func.labels.push(switchLabel);</pre></div></div>
            
        </li>
        
        
        <li id="section-183">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-183">&#182;</a>
              </div>
              <p>Statements under must be grouped (by label) in SwitchCase
nodes. <code>cur</code> is used to keep the node that we are currently
adding statements to.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="keyword">var</span> cur, seen = [], defaultCase = <span class="literal">null</span>;
                <span class="keyword">while</span> (!eat(_braceR)) {
                    <span class="keyword">if</span> (tokType === _<span class="keyword">case</span> || tokType === _<span class="keyword">default</span>) {
                        <span class="keyword">var</span> isCase = (tokType === _<span class="keyword">case</span>);
                        <span class="keyword">if</span> (cur) { <span class="comment">/* finish case */</span> }
                        cur = {test:<span class="literal">null</span>,consequent:[]};
                        next();
                        <span class="keyword">if</span> (isCase) {
                            startPos = tokStart;
                            cur.test = parseNumericLiteral();
                            typecheck(cur.test.type, Types.Signed,
                                      <span class="string">"switch case"</span>, startPos);
                            <span class="keyword">if</span> (seen[cur.test.value]) {
                                raise(startPos, <span class="string">"Duplicate case"</span>);
                            } <span class="keyword">else</span> { seen[cur.test.value] = cur; }
                        } <span class="keyword">else</span> {
                            <span class="keyword">if</span> (defaultCase !== <span class="literal">null</span>) {
                                raise(lastStart, <span class="string">"Multiple default clauses"</span>);
                            }
                            defaultCase = cur;
                        }
                        expect(_colon);
                    } <span class="keyword">else</span> {
                        <span class="keyword">if</span> (!cur) { unexpected(); }
                        cur.consequent.push(parseStatement());
                    }
                }
                <span class="keyword">if</span> (cur) { <span class="comment">/* finish case */</span> }
                module.func.labels.pop();
                <span class="comment">/* verify that range of switch cases is reasonable */</span>
                <span class="keyword">var</span> nums = Object.keys(seen);
                <span class="keyword">if</span> (nums.length &gt; <span class="number">0</span>) {
                    <span class="keyword">var</span> min = nums.reduce(Math.min);
                    <span class="keyword">var</span> max = nums.reduce(Math.max);
                    <span class="keyword">if</span> ((max - min) &gt;= Math.pow(<span class="number">2</span>,<span class="number">31</span>)) {
                        raise(lastStart, <span class="string">"Range between minimum and maximum "</span>+
                              <span class="string">"case label is too large."</span>);
                    }
                }
                <span class="keyword">return</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-184">
            <div class="annotation">
              
              <div class="pilwrap for-h4">
                <a class="pilcrow" href="#section-184">&#182;</a>
              </div>
              <h4>BlockStatement</h4>

            </div>
            
            <div class="content"><div class='highlight'><pre>            } <span class="keyword">else</span> <span class="keyword">if</span> (starttype===_braceL) {
                <span class="keyword">return</span> parseBlock();</pre></div></div>
            
        </li>
        
        
        <li id="section-185">
            <div class="annotation">
              
              <div class="pilwrap for-h4">
                <a class="pilcrow" href="#section-185">&#182;</a>
              </div>
              <h4>EmptyStatement</h4>

            </div>
            
            <div class="content"><div class='highlight'><pre>            } <span class="keyword">else</span> <span class="keyword">if</span> (starttype===_semi) {
                next();
                <span class="keyword">return</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-186">
            <div class="annotation">
              
              <div class="pilwrap for-h4">
                <a class="pilcrow" href="#section-186">&#182;</a>
              </div>
              <h4>ExpressionStatement / LabeledStatement</h4>

            </div>
            
            <div class="content"><div class='highlight'><pre>            } <span class="keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-187">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-187">&#182;</a>
              </div>
              <p>If the statement does not start with a statement keyword or a
brace, it&#39;s an ExpressionStatement or LabeledStatement.</p>
<p>We look ahead to see if the next two tokens are
an identifier followed by a colon.  If not, we have to
backtrack and reparse as an ExpressionStatement.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="keyword">if</span> (starttype===_name) {
                    <span class="keyword">var</span> maybeStart = tokStart;
                    <span class="keyword">var</span> maybeName = parseIdent();
                    <span class="keyword">if</span> (eat(_colon)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-188">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-188">&#182;</a>
              </div>
              <p>Sure enough, this was a LabeledStatement.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                        module.func.labels.forEach(<span class="keyword">function</span>(l) {
                            <span class="keyword">if</span> (l.name === maybeName) {
                                raise(maybeStart, <span class="string">"Label '"</span> + maybeName +
                                      <span class="string">"' is already declared"</span>);
                            }
                        });
                        <span class="keyword">var</span> kind = tokType.isLoop ? <span class="string">"loop"</span> :
                            (tokType === _<span class="keyword">switch</span>) ? <span class="string">"switch"</span> : <span class="literal">null</span>;
                        module.func.labels.push({name: maybeName, kind: kind});
                        <span class="keyword">var</span> labeledStatement = parseStatement();
                        module.func.labels.pop();
                        <span class="keyword">return</span>;
                    } <span class="keyword">else</span> {
                        backtrack(maybeStart);
                    }
                }</pre></div></div>
            
        </li>
        
        
        <li id="section-189">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-189">&#182;</a>
              </div>
              <p>Nope, this is an ExpressionStatement.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="keyword">var</span> expr = parseExpression();
                semicolon();
                <span class="keyword">return</span>;
            }
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-190">
            <div class="annotation">
              
              <div class="pilwrap for-h4">
                <a class="pilcrow" href="#section-190">&#182;</a>
              </div>
              <h4>ForStatement</h4>
<p>Parse a regular <code>for</code> loop. The disambiguation code in
<code>parseStatement</code> will already have parsed the init statement or
expression.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        parseFor = <span class="keyword">function</span>(init) {
            expect(_semi);
            <span class="keyword">var</span> startPos = tokStart;
            <span class="keyword">var</span> test = (tokType === _semi) ? <span class="literal">null</span> :
                defcheck(parseExpression());
            <span class="keyword">if</span> (test!==<span class="literal">null</span>) {
                typecheck(test.type, Types.Int, <span class="string">"for-loop condition"</span>, startPos);
            }
            expect(_semi);
            <span class="keyword">var</span> update = (tokType === _parenR) ? <span class="literal">null</span> :
                defcheck(parseExpression());
            expect(_parenR);
            <span class="keyword">var</span> body = parseStatement();
            module.func.labels.pop();
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-191">
            <div class="annotation">
              
              <div class="pilwrap for-h4">
                <a class="pilcrow" href="#section-191">&#182;</a>
              </div>
              <h4>Block</h4>
<p>Parse a semicolon-enclosed block of statements.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        parseBlock = <span class="keyword">function</span>() {
            expect(_braceL);
            <span class="keyword">while</span> (!eat(_braceR)) {
                parseStatement();
            }
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-192">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-192">&#182;</a>
              </div>
              <p>XXX second parameter to parseExpression is never true for asm.js</p>
<h3>Module-internal function parsing</h3>
<p>Parse a list of parameter type coercions.
Note that we can&#39;t always tell these apart from body statements;
we might have to backtrack.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> parseParameterTypeCoercions = <span class="keyword">function</span>() {
            <span class="keyword">var</span> func = module.func;
            <span class="keyword">var</span> ptPos;</pre></div></div>
            
        </li>
        
        
        <li id="section-193">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-193">&#182;</a>
              </div>
              <p>Restore old token position before returning.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">var</span> bail = <span class="keyword">function</span>() { <span class="keyword">return</span> backtrack(ptPos); };
            <span class="keyword">while</span> (tokType === _name) {</pre></div></div>
            
        </li>
        
        
        <li id="section-194">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-194">&#182;</a>
              </div>
              <p>Save position of this token before starting to parse!</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                ptPos = tokStart;
                <span class="keyword">var</span> x = parseIdent();
                <span class="keyword">var</span> binding = func.env.lookup(x);
                <span class="keyword">if</span> (binding===<span class="literal">null</span> || binding.type!==Types.ForwardReference) {
                    <span class="keyword">return</span> bail(); <span class="comment">// not a parameter name, or already coerced</span>
                }
                <span class="keyword">if</span> (tokType === _eq) { next(); } <span class="keyword">else</span> { <span class="keyword">return</span> bail(); }
                <span class="keyword">if</span> (tokType === _name &amp;&amp; tokVal === x) {</pre></div></div>
            
        </li>
        
        
        <li id="section-195">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-195">&#182;</a>
              </div>
              <p>This is an <code>int</code> type annotation.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    next();
                    <span class="keyword">if</span> (!(tokType === _bin3 &amp;&amp; tokVal === <span class="string">'|'</span>)) {
                        <span class="keyword">return</span> bail();
                    } <span class="keyword">else</span> { next(); }
                    <span class="keyword">if</span> (!(tokType === _num &amp;&amp; tokVal === <span class="number">0</span>)) {
                        <span class="keyword">return</span> bail();
                    } <span class="keyword">else</span> { next(); }
                    <span class="keyword">if</span> (!(tokType === _semi)) { <span class="keyword">return</span> bail(); }
                    binding.type = mergeTypes(binding.type, Types.Int, ptPos);
                } <span class="keyword">else</span> <span class="keyword">if</span> (tokType === _plusmin &amp;&amp; tokVal===<span class="string">'+'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-196">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-196">&#182;</a>
              </div>
              <p>This is a <code>double</code> type annotation.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    next();
                    <span class="keyword">if</span> (tokType === _name &amp;&amp; tokVal === x) {
                        next();
                    } <span class="keyword">else</span> { <span class="keyword">return</span> bail(); }
                    <span class="keyword">if</span> (!(tokType === _semi)) { <span class="keyword">return</span> bail(); }
                    binding.type=mergeTypes(binding.type, Types.Double, ptPos);
                } <span class="keyword">else</span> {
                    <span class="keyword">return</span> bail();
                }
                expect(_semi);
            }
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-197">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-197">&#182;</a>
              </div>
              <p>Parse local variable declarations.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> parseLocalVariableDeclarations = <span class="keyword">function</span>() {
            <span class="keyword">var</span> func = module.func;
            <span class="keyword">while</span> (tokType === _<span class="keyword">var</span>) {
                expect(_<span class="keyword">var</span>);
                <span class="keyword">while</span> (<span class="literal">true</span>) {
                    <span class="keyword">var</span> yPos = tokStart;
                    <span class="keyword">var</span> y = parseIdent();
                    expect(_eq);
                    <span class="keyword">var</span> n = parseNumericLiteral();
                    <span class="keyword">var</span> ty = (n.type===Types.Double) ? Types.Double : Types.Int;
                    func.env.bind(y, LocalBinding.New(ty), yPos);
                    <span class="keyword">if</span> (!eat(_comma)) { <span class="keyword">break</span>; }
                }
                semicolon();
            }
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-198">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-198">&#182;</a>
              </div>
              <p>Parse a module-internal function</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> parseFunctionDeclaration = <span class="keyword">function</span>() {
            <span class="keyword">var</span> fPos = tokStart, param, paramStart;
            <span class="keyword">var</span> func = module.func = {
                id: <span class="literal">null</span>,
                params: [],
                env: Env.New(),
                retType: Types.ForwardReference,
                labels: []
            };
            module.functions.push(func);
            expect(_<span class="keyword">function</span>);
            func.id = parseIdent();
            expect(_parenL);
            <span class="keyword">while</span> (!eat(_parenR)) {
                <span class="keyword">if</span> (func.params.length !== <span class="number">0</span>) { expect(_comma); }
                paramStart = tokStart;
                param = parseIdent();
                func.params.push(param);
                func.env.bind(param, LocalBinding.New(Types.ForwardReference),
                              paramStart);
            }
            expect(_braceL);</pre></div></div>
            
        </li>
        
        
        <li id="section-199">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-199">&#182;</a>
              </div>
              <p>Parse the parameter type coercion statements, then
verify that all the parameters were coerced to a type.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            parseParameterTypeCoercions();
            func.params.forEach(<span class="keyword">function</span>(param) {
                <span class="keyword">if</span> (func.env.lookup(param).type===Types.ForwardReference) {
                    raise(fPos, <span class="string">"No parameter type annotation found for '"</span> +
                          param + <span class="string">"'"</span>);
                }
            });

            parseLocalVariableDeclarations();</pre></div></div>
            
        </li>
        
        
        <li id="section-200">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-200">&#182;</a>
              </div>
              <p>Parse the body statements.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">while</span> (!eat(_braceR)) {
                parseStatement();
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-201">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-201">&#182;</a>
              </div>
              <p>Now reconcile the type of the function.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">if</span> (func.retType === Types.ForwardReference) {</pre></div></div>
            
        </li>
        
        
        <li id="section-202">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-202">&#182;</a>
              </div>
              <p>If no return statement was seen, this function returns
<code>void</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                func.retType = Types.Void;
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-203">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-203">&#182;</a>
              </div>
              <p>Broaden return type to intish or doublish.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">if</span> (func.retType.isSubtypeOf(Types.Intish)) {
                func.retType = Types.Intish;
            } <span class="keyword">else</span> <span class="keyword">if</span> (func.retType.isSubtypeOf(Types.Doublish)) {
                func.retType = Types.Doublish;
            } <span class="keyword">else</span> {
                console.assert(<span class="literal">false</span>, func.retType.toString());
            }
            <span class="keyword">var</span> ty = Types.Arrow(func.params.map(<span class="keyword">function</span>(p) {
                <span class="keyword">return</span> func.env.lookup(p).type;
            }), func.retType);
            <span class="keyword">var</span> binding = module.env.lookup(func.id);
            <span class="keyword">if</span> (binding===<span class="literal">null</span> || !binding.pending) {</pre></div></div>
            
        </li>
        
        
        <li id="section-204">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-204">&#182;</a>
              </div>
              <p>If the binding is not pending, the attempt to bind will
raise the proper &quot;duplicate definition&quot; error.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                module.env.bind(func.id, GlobalBinding.New(ty, <span class="literal">false</span>));
            } <span class="keyword">else</span> {
                console.assert(GlobalBinding.hasInstance(binding) &amp;&amp;
                               !binding.mutable);
                binding.type = mergeTypes(binding.type, ty, fPos);
                binding.pending = <span class="literal">false</span>; <span class="comment">// type is now authoritative.</span>
            }
            <span class="comment">/* done with this function */</span>
            module.func = <span class="literal">null</span>;
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-205">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-205">&#182;</a>
              </div>
              <h3>Module parsing</h3>
<p>Parse a variable statement within a module.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> parseModuleVariableStatement = <span class="keyword">function</span>() {
            <span class="keyword">var</span> x, y, ty, startPos, yPos;
            expect(_<span class="keyword">var</span>);
            startPos = tokStart;
            x = parseIdent();
            expect(_eq);</pre></div></div>
            
        </li>
        
        
        <li id="section-206">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-206">&#182;</a>
              </div>
              <p>There are five types of variable statements:</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">if</span> (tokType === _bracketL) {</pre></div></div>
            
        </li>
        
        
        <li id="section-207">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-207">&#182;</a>
              </div>
              <p>1. A function table.  (Only allowed at end of module.)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                yPos = tokStart; next();
                <span class="keyword">var</span> table = [], lastType;
                <span class="keyword">while</span> (!eat(_bracketR)) {
                    <span class="keyword">if</span> (table.length &gt; <span class="number">0</span>) { expect(_comma); }
                    y = parseIdent();
                    <span class="keyword">var</span> b = module.env.lookup(y);
                    <span class="comment">/* validate consistent types of named functions */</span>
                    <span class="keyword">if</span> (!b) { raise(lastStart, <span class="string">"Unknown function '"</span>+y+<span class="string">"'"</span>); }
                    <span class="keyword">if</span> (b.mutable) {
                        raise(lastStart, <span class="string">"'"</span>+y+<span class="string">"' must be immutable"</span>);
                    }
                    <span class="keyword">if</span> (!b.type.arrow) {
                        raise(lastStart, <span class="string">"'"</span>+y+<span class="string">"' must be a function"</span>);
                    }
                    <span class="keyword">if</span> (table.length &gt; <span class="number">0</span> &amp;&amp;
                        b.type !== lastType) {
                        raise(lastStart, <span class="string">"Inconsistent function type in table"</span>);
                    }
                    lastType = b.type;
                    table.push(b);
                }
                <span class="comment">/* check that the length is a power of 2. */</span>
                <span class="keyword">if</span> (table.length===<span class="number">0</span>) {
                    raise(yPos, <span class="string">"Empty function table."</span>);
                } <span class="keyword">else</span> <span class="keyword">if</span> (!powerOf2(table.length)) {
                    raise(yPos, <span class="string">"Function table length is not a power of 2."</span>);
                }
                ty = Types.Table(lastType, table.length);
                <span class="keyword">var</span> binding = module.env.lookup(x);
                <span class="keyword">if</span> (binding === <span class="literal">null</span> || !binding.pending) {
                    module.env.bind(x, GlobalBinding.New(ty, <span class="literal">false</span>), startPos);
                } <span class="keyword">else</span> {
                    console.assert(GlobalBinding.hasInstance(binding) &amp;&amp;
                                   !binding.mutable);
                    binding.type = mergeTypes(binding.type, ty, startPos);
                    binding.pending = <span class="literal">false</span>; <span class="comment">// binding is now authoritative.</span>
                }
                module.seenTable = <span class="literal">true</span>;
            } <span class="keyword">else</span> <span class="keyword">if</span> (module.seenTable) {
                raise(tokStart, <span class="string">"expected function table"</span>);
            } <span class="keyword">else</span> <span class="keyword">if</span> (tokType === _num || tokType === _dotnum ||
                       (tokType === _plusmin &amp;&amp; tokVal===<span class="string">'-'</span>)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-208">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-208">&#182;</a>
              </div>
              <p>2. A global program variable, initialized to a literal.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                y = parseNumericLiteral();
                ty = (y.type===Types.Double) ? Types.Double : Types.Int;
                module.env.bind(x, GlobalBinding.New(ty, <span class="literal">true</span>), startPos);
            } <span class="keyword">else</span> <span class="keyword">if</span> (tokType === _name &amp;&amp; tokVal === module.stdlib) {</pre></div></div>
            
        </li>
        
        
        <li id="section-209">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-209">&#182;</a>
              </div>
              <p>3. A standard library import.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                next(); expect(_dot);
                yPos = tokStart;
                y = parseIdent();
                <span class="keyword">if</span> (y===<span class="string">'Math'</span>) {
                    expect(_dot); y += <span class="string">'.'</span> + parseIdent();
                }
                ty = Types.stdlib[y];
                <span class="keyword">if</span> (!ty) { raise(yPos, <span class="string">"Unknown library import"</span>); }
                module.env.bind(x, GlobalBinding.New(ty, <span class="literal">false</span>), startPos);
            } <span class="keyword">else</span> <span class="keyword">if</span> ((tokType === _plusmin &amp;&amp; tokVal===<span class="string">'+'</span>) ||
                       (tokType === _name &amp;&amp; tokVal === module.foreign)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-210">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-210">&#182;</a>
              </div>
              <p>4. A foreign import.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="keyword">var</span> sawPlus = <span class="literal">false</span>, sawBar = <span class="literal">false</span>;
                <span class="keyword">if</span> (tokType===_plusmin) { next(); sawPlus = <span class="literal">true</span>; }
                expectName(module.foreign, <span class="string">"&lt;foreign&gt;"</span>); expect(_dot);
                y = parseIdent();
                <span class="keyword">if</span> (tokType === _bin3 &amp;&amp; tokVal ===<span class="string">'|'</span> &amp;&amp; !sawPlus) {
                    next(); sawBar = <span class="literal">true</span>;
                    <span class="keyword">if</span> (tokType !== _num || tokVal !== <span class="number">0</span>) {
                        raise(tokStart, <span class="string">"expected 0"</span>);
                    }
                    next();
                }
                ty = sawPlus ? Types.Double : sawBar ? Types.Int :
                    Types.Function;
                module.env.bind(x, GlobalBinding.New(ty, <span class="literal">false</span>), startPos);
            } <span class="keyword">else</span> <span class="keyword">if</span> (tokType === _<span class="keyword">new</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-211">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-211">&#182;</a>
              </div>
              <p>5. A global heap view.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                next(); expectName(module.stdlib, <span class="string">"&lt;stdlib&gt;"</span>); expect(_dot);
                yPos = tokStart;
                <span class="keyword">var</span> view = parseIdent();
                <span class="keyword">if</span> (view === <span class="string">'Int8Array'</span>) { ty = Types.IntArray(<span class="number">8</span>); }
                <span class="keyword">else</span> <span class="keyword">if</span> (view === <span class="string">'Uint8Array'</span>) { ty = Types.UintArray(<span class="number">8</span>); }
                <span class="keyword">else</span> <span class="keyword">if</span> (view === <span class="string">'Int16Array'</span>) { ty = Types.IntArray(<span class="number">16</span>); }
                <span class="keyword">else</span> <span class="keyword">if</span> (view === <span class="string">'Uint16Array'</span>) { ty = Types.UintArray(<span class="number">16</span>); }
                <span class="keyword">else</span> <span class="keyword">if</span> (view === <span class="string">'Int32Array'</span>) { ty = Types.IntArray(<span class="number">32</span>); }
                <span class="keyword">else</span> <span class="keyword">if</span> (view === <span class="string">'Uint32Array'</span>) { ty = Types.UintArray(<span class="number">32</span>); }
                <span class="keyword">else</span> <span class="keyword">if</span> (view === <span class="string">'Float32Array'</span>) { ty = Types.FloatArray(<span class="number">32</span>); }
                <span class="keyword">else</span> <span class="keyword">if</span> (view === <span class="string">'Float64Array'</span>) { ty = Types.FloatArray(<span class="number">64</span>); }
                <span class="keyword">else</span> { raise(yPos, <span class="string">"unknown ArrayBufferView type"</span>); }
                expect(_parenL);
                expectName(module.heap, <span class="string">"&lt;heap&gt;"</span>);
                expect(_parenR);
                module.env.bind(x, GlobalBinding.New(ty, <span class="literal">false</span>), startPos);
            } <span class="keyword">else</span> { unexpected(); }
            semicolon();
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-212">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-212">&#182;</a>
              </div>
              <p>Parse a series of module variable declaration statements.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> parseModuleVariableStatements = <span class="keyword">function</span>() {
            <span class="keyword">while</span> (tokType === _<span class="keyword">var</span>) {
                parseModuleVariableStatement();
            }
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-213">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-213">&#182;</a>
              </div>
              <p>Parse a series of (module-internal) function declarations.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> parseModuleFunctionDeclarations = <span class="keyword">function</span>() {
            <span class="keyword">while</span> (tokType === _<span class="keyword">function</span>) {
                parseFunctionDeclaration();
            }
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-214">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-214">&#182;</a>
              </div>
              <p>Parse the module export declaration (return statement).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> parseModuleExportDeclaration = <span class="keyword">function</span>() {
            expect(_<span class="keyword">return</span>);
            <span class="keyword">var</span> exports = module.exports = Object.create(<span class="literal">null</span>), first = <span class="literal">true</span>;
            <span class="keyword">var</span> fStart = tokStart;
            <span class="keyword">var</span> check = <span class="keyword">function</span>(f) {
                <span class="keyword">var</span> binding = module.env.lookup(f);
                <span class="keyword">if</span> (!binding) { raise(fStart, <span class="string">"Unknown function '"</span>+f+<span class="string">"'"</span>); }
                <span class="keyword">if</span> (binding.mutable) { raise(fStart, <span class="string">"mutable export"</span>); }
                <span class="keyword">if</span> (!binding.type.arrow) { raise(fStart, <span class="string">"not a function"</span>); }
                <span class="keyword">return</span> f;
            };
            <span class="keyword">if</span> (tokType !== _braceL) {
                exports[<span class="string">'#'</span>] = check(parseIdent());
            } <span class="keyword">else</span> {
                next();
                <span class="keyword">var</span> x = parseIdent();
                expect(_colon);
                fStart = tokStart;
                <span class="keyword">var</span> f = parseIdent();
                exports[x] = check(f);
                <span class="keyword">while</span> (!eat(_braceR)) {
                    expect(_comma);
                    x = parseIdent();
                    expect(_colon);
                    f = parseIdent();
                    exports[x] = check(f);
                }
            }
            semicolon();
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-215">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-215">&#182;</a>
              </div>
              <p>Parse one asm.js module; it should start with &#39;function&#39; keyword.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="comment">/* XXX support the FunctionExpression form. */</span>
        <span class="keyword">var</span> parseModule = <span class="keyword">function</span>() {</pre></div></div>
            
        </li>
        
        
        <li id="section-216">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-216">&#182;</a>
              </div>
              <p>Set up a new module in the parse context.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            module = {
                id: <span class="literal">null</span>,
                stdlib: <span class="literal">null</span>, foreign: <span class="literal">null</span>, heap: <span class="literal">null</span>,
                seenTable: <span class="literal">false</span>,
                env: Env.New(), <span class="comment">// new global environment</span>
                functions: [],
                func: <span class="literal">null</span> <span class="comment">// the function we are currently parsing.</span>
            };
            <span class="keyword">var</span> modbinding = GlobalBinding.New(Types.Module, <span class="literal">false</span>);
            expect(_<span class="keyword">function</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-217">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-217">&#182;</a>
              </div>
              <p>Parse the (optional) module name.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">if</span> (tokType === _name) {
                module.id = parseIdent();
                module.env.bind(module.id, modbinding, lastStart);
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-218">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-218">&#182;</a>
              </div>
              <p>Parse the module parameters.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            expect(_parenL);
            <span class="keyword">if</span> (!eat(_parenR)) {
                module.stdlib = parseIdent();
                module.env.bind(module.stdlib, modbinding, lastStart);
                <span class="keyword">if</span> (!eat(_parenR)) {
                    expect(_comma);
                    module.foreign = parseIdent();
                    module.env.bind(module.foreign, modbinding, lastStart);
                    <span class="keyword">if</span> (!eat(_parenR)) {
                        expect(_comma);
                        module.heap = parseIdent();
                        module.env.bind(module.heap, modbinding, lastStart);
                        expect(_parenR);
                    }
                }
            }
            expect(_braceL);</pre></div></div>
            
        </li>
        
        
        <li id="section-219">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-219">&#182;</a>
              </div>
              <p>Check for &quot;use asm&quot;.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">if</span> (tokType !== _string ||
                tokVal !== <span class="string">"use asm"</span>) {
                raise(tokStart, <span class="string">"Expected to see 'use asm'"</span>);
            }
            next();
            semicolon();</pre></div></div>
            
        </li>
        
        
        <li id="section-220">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-220">&#182;</a>
              </div>
              <p>Parse the body of the module.  Note that
the <code>parseModuleVariableStatements</code> function also handles
function table declaration statements.  If there are no
module function declarations, we might parse the whole
thing in one go... so check for this case.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            parseModuleVariableStatements();
            <span class="keyword">if</span> (!module.seenTable) {
                module.seenTable = <span class="literal">true</span>;
                parseModuleFunctionDeclarations();
                parseModuleVariableStatements();
            }
            parseModuleExportDeclaration();
            expect(_braceR);</pre></div></div>
            
        </li>
        
        
        <li id="section-221">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-221">&#182;</a>
              </div>
              <p>XXX Verify that there are no longer any pending global types.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">return</span> module;
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-222">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-222">&#182;</a>
              </div>
              <p>Parse a sequence of asm.js modules.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        parseTopLevel = <span class="keyword">function</span>() {
            lastStart = lastEnd = tokPos;
            <span class="keyword">if</span> (options.locations) { lastEndLoc = line_loc_t.New(); }
            readToken();

            <span class="keyword">var</span> modules = [];
            <span class="keyword">while</span> (tokType !== _eof) {
                modules.push(parseModule());
            }
            <span class="keyword">return</span> modules;
        };

    };</pre></div></div>
            
        </li>
        
        
        <li id="section-223">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-223">&#182;</a>
              </div>
              <h2>Exported interface functions</h2>
<p>Finally, set up the exported functions, which encapsulate the
compiler/tokenizer state.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> tokenize = asm_llvm_module.tokenize = <span class="keyword">function</span>(source, opts) {
        <span class="keyword">return</span> Compiler.New().tokenize(source, opts);
    };

    <span class="keyword">var</span> compile = asm_llvm_module.compile = <span class="keyword">function</span>(source, opts) {
        <span class="keyword">return</span> Compiler.New().parse(source, opts);
    };

    <span class="keyword">return</span> asm_llvm_module;
});</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
