// Utility to write out the opcode mapping from bytecode-table.js
// as a Rust module.
// Run it under node with the CLI in bin/write-rust-ops.js
define(['./bytecode-table'], function(bytecode_table) {
    var bops = [];
    for (var i = 0; ; i++) {
        var bc = bytecode_table.for_num(i);
        if (!bc) { break; }
        bops.push(bc);
    }
    var comma = function(i) { return (i < (bops.length-1)) ? ',' : ''; };

    console.log('// generated by TurtleScript write-rust-ops.js');
    console.log('');

    // emit Op enumeration
    console.log('pub enum Op {');
    bops.forEach(function(bc, i) {
        console.log('  Op_' + bc.name + ' = ' + i + comma(i));
    });
    console.log('}');
    console.log('');

    // emit args function
    console.log('impl Op {');
    console.log('  pub fn args(&self) -> uint {');
    console.log('    match *self {');
    bops.forEach(function(bc, i) {
        console.log('      Op_' + bc.name + ' => ' + bc.args + comma(i));
    });
    console.log('    }');
    console.log('  }');
    console.log('  pub fn stackpush(&self) -> uint {');
    console.log('    match *self {');
    bops.forEach(function(bc, i) {
        console.log('      Op_' + bc.name + ' => ' + bc.stackpush() + comma(i));
    });
    console.log('    }');
    console.log('  }');
    console.log('  pub fn stackpop(&self, args: &[int]) -> uint {');
    console.log('    match *self {');
    bops.forEach(function(bc, i) {
        var stackpop = bc.stackpop();
        if (bc.name === 'invoke') {
            stackpop = '(args[0] as uint) + 2';
        }
        console.log('      Op_' + bc.name + ' => ' + stackpop + comma(i));
    });
    console.log('    }');
    console.log('  }');
    console.log('  pub fn new_from_uint(val: uint) -> Op {');
    console.log('    match val {');
    bops.forEach(function(bc, i) {
        console.log('      ' + i + ' => Op_' + bc.name + ',');
    });
    console.log('      _ => fail!()');
    console.log('    }');
    console.log('  }');
    console.log('}');

    // unit tests
    console.log('');
    console.log('#[test]');
    console.log('fn test_invoke() {');
    console.log('  let op = Op_invoke;');
    console.log('  let args : &[int] = &[3];');
    console.log('  assert!(op.stackpop(args) == 5);');
    console.log('}');
    console.log('#[test]');
    console.log('fn test_cast() {');
    console.log('  let op1a = Op_push_literal;');
    console.log('  let op1b = Op::new_from_uint(1);');
    console.log('  assert!((op1a as int) == 1);');
    console.log('  assert!((op1b as int) == 1);');
    console.log('}');
});
