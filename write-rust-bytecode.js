#!/usr/bin/env node
var requirejs = require('requirejs');

requirejs.config({
    nodeRequire: require
});

requirejs.define('timeouts', { setTimeout: null, clearTimeout: null });

requirejs(['./parse', './bcompile', './bytecode-table', './tests'], function(parse, bcompile, bytecode_table, tests) {
    var fake_require =
        "var __modules__ = {};\n"+
        "define = function(name, deps, init_func) {\n"+
        "  function map(a, f) {\n"+
        "    var i = 0, r = [];\n"+
        "    while (i < a.length) {\n"+
        "      r[i] = f(a[i]);\n"+
        "      i+=1;\n"+
        "    }\n"+
        "    return r;\n"+
        "  }\n"+
        "  var d = map(deps, function(m) { return __modules__[m]; });\n"+
        "  __modules__[name] = init_func.apply(this, d);\n"+
        "};\n";
    var make_compile_from_source = function(parse, bcompile) {
       return function (source) {
           var result;
           source = source || '{ return 1+2; }';
           //result = tokenize(source, '=<>!+-*&|/%^', '=<>&|');
           var tree = parse(source, "isFinite parseInt isNaN "+
                            "Boolean String Function Math "+
                            "console arguments now define document");
           //result = tree;
           var bc = bcompile(tree);
           result = bc;
           return result;
       };
    };
    var cfs_source = make_compile_from_source.toSource ?
        make_compile_from_source.toSource() :
        make_compile_from_source.toString();
    cfs_source = 'define("compile_from_source", ["parse","bcompile"], '+
        cfs_source + ');\n';
    source = '{' + fake_require +
        tests.lookup("stdlib")+"\n"+
        tests.lookup("tokenize")+"\n"+
        tests.lookup("parse")+"\n"+
        tests.lookup("bytecode-table")+"\n"+
        tests.lookup("bcompile")+"\n"+
        cfs_source + '\n' +
        "return __modules__['compile_from_source']; }\n";

    // XXX hack for initial tests
    //source = "{ console.log('Hello, world!'); }";

    var compile_from_source = make_compile_from_source(parse, bcompile);
    var bc = compile_from_source(source);

    // output functions.
    console.log('// generated by TurtleScript write-rust-bytecode.js');
    console.log('use function::Function;');
    console.log('use literal::*;');
    console.log('');
    console.log('pub fn init(functions: &mut ~[Function], literals: &mut ~[Literal]) {');
    console.log('  // functions');
    bc.functions.forEach(function(f, i) {
        var name = f.name ? (' // '+JSON.stringify(f.name)) : '';
        console.log('  vec::push(functions, Function {' + name);
        console.log('    id: ' + f.id + ',');
        console.log('    nargs: ' + f.nargs + ',');
        console.log('    max_stack: ' + f.max_stack + ',');
        console.log('    bytecode: ~[');
        for (var j=0; j<f.bytecode.length; ) {
            var bc = bytecode_table.for_num(f.bytecode[j]);
            var a = f.bytecode.slice(j, j+=bc.args+1);
            a = a.map(function(b) {
                if (typeof(b) !== 'number') { b = b.label; }
                return ''+b;
            }).join(', ');
            if (j < f.bytecode.length) { a += ','; }
            console.log('      ' + a + ' // ' + bc.name+'('+bc.args+')');
        }
        console.log('    ]');
        console.log('  });');
    });
    console.log('');
    console.log('  // literals');
    bc.literals.forEach(function(lv, i) {
        var str;
        if (typeof(lv) === "number" ) {
            str = lv.toString() + 'f64';
            if (isNaN(lv)) { str = 'f64::NaN'; }
            if (!isFinite(lv)) { str = 'f64::infinity'; }
            str = "Number(" + str + ")";
        } else if (typeof(lv) === "string") {
            str = '"' + lv.replace(/[^A-Za-z0-9_ !#-\/:-@\[\]^`{|}~]/g, function(c) {
                c = c.charCodeAt(0).toString(16);
                while (c.length < 2) { c = '0' + c; }
                if (c.length === 2) { return "\\x" + c; }
                while (c.length < 4) { c = '0' + c; }
                return "\\u" + c;
            }) + '"';
            str = "String(~" + str + ")";
        } else if (typeof(lv) === "boolean") {
            str = "Boolean(" + (lv ? "true" : "false") + ")";
        } else if (lv === null) {
            str = "Null";
        } else if (lv === undefined) {
            str = "Undefined";
        } else {
            console.assert(false);
        }
        console.log('  vec::push(literals, '+str+');');
    });
    console.log('}');
    // XXX for a static array, we could also do:
    //   static functions : &'static[Function] = &[];

    //console.log(bc);
});
