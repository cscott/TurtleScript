#!/usr/bin/env node
var requirejs = require('requirejs');

requirejs.config({
    nodeRequire: require
});

requirejs.define('timeouts', { setTimeout: null, clearTimeout: null });

requirejs(['./parse', './bcompile', './bytecode-table', './tests'], function(parse, bcompile, bytecode_table, tests) {
    var fake_require =
        "var __modules__ = {};\n"+
        "define = function(name, deps, init_func) {\n"+
        "  function map(a, f) {\n"+
        "    var i = 0, r = [];\n"+
        "    while (i < a.length) {\n"+
        "      r[i] = f(a[i]);\n"+
        "      i+=1;\n"+
        "    }\n"+
        "    return r;\n"+
        "  }\n"+
        "  var d = map(deps, function(m) { return __modules__[m]; });\n"+
        "  __modules__[name] = init_func.apply(this, d);\n"+
        "};\n";
    var make_compile_from_source = function(parse, bcompile) {
       return function (source) {
           var result;
           source = source || '{ return 1+2; }';
           //result = tokenize(source, '=<>!+-*&|/%^', '=<>&|');
           var tree = parse(source, "isFinite parseInt isNaN "+
                            "Boolean String Function Math "+
                            "console arguments now define document");
           //result = tree;
           var bc = bcompile(tree);
           result = bc;
           return result;
       };
    };
    var cfs_source = make_compile_from_source.toSource ?
        make_compile_from_source.toSource() :
        make_compile_from_source.toString();
    cfs_source = 'define("compile_from_source", ["parse","bcompile"], '+
        cfs_source + ');\n';
    source = '{' + fake_require +
        tests.lookup("stdlib")+"\n"+
        tests.lookup("tokenize")+"\n"+
        tests.lookup("parse")+"\n"+
        tests.lookup("bytecode-table")+"\n"+
        tests.lookup("bcompile")+"\n"+
        cfs_source + '\n' +
        "return __modules__['compile_from_source']; }\n";

    // XXX hack for initial tests
    source = "{ console.log('Hello,', 'world!'); }";

    var compile_from_source = make_compile_from_source(parse, bcompile);
    var bc = compile_from_source(source);

    var rust_esc = function(str) {
        // escape string for rust -- note UTF-16 to UCS4 conversion.
        var re = /[\uD800-\uDBFF][\uDC00-\uDFFF]|[^A-Za-z0-9_ !#-\/:-@\[\]^`{|}~]/g;
        return '"' + str.replace(re, function(c) {
            var code = c.charCodeAt(0);
            if (c.length===2) {
                var next = c.charCodeAt(1);
                code = ((code - 0xD800) * 0x400) +
                    (next - 0xDC00) + 0x10000;
            }
            c = code.toString(16);
            while (c.length < 2) { c = '0' + c; }
            if (c.length === 2) { return "\\x" + c; }
            while (c.length < 4) { c = '0' + c; }
            if (c.length === 4) { return "\\u" + c; }
            while (c.length < 8) { c = '0' + c; }
            return "\\U" + c;
        }) + '"';
    };

    // output functions.
    console.log('// generated by TurtleScript write-rust-bytecode.js');
    console.log('use function::Function;');
    console.log('use object::{JsVal,JsNumber,JsBool,JsUndefined,JsNull};');
    //console.log('// test: '+rust_esc('abc\uD800\uDC00def\ng')); // test UTF16
    console.log('');
    console.log('pub fn init(functions: &mut ~[Function], literals: &mut ~[JsVal]) {');
    console.log('  // functions');
    bc.functions.forEach(function(f, i) {
        var name = f.name ? (' // '+JSON.stringify(f.name)) : '';
        console.log('  vec::push(functions, Function {' + name);
        name = f.name ? ('Some(~'+rust_esc(f.name)+')') : 'None';
        console.log('    name: ' + name + ',');
        console.log('    id: ' + f.id + ',');
        console.log('    nargs: ' + f.nargs + ',');
        console.log('    max_stack: ' + f.max_stack + ',');
        console.log('    bytecode: ~[');
        for (var j=0; j<f.bytecode.length; ) {
            var bc = bytecode_table.for_num(f.bytecode[j]);
            var a = f.bytecode.slice(j, j+=bc.args+1);
            a = a.map(function(b) {
                if (typeof(b) !== 'number') { b = b.label; }
                return ''+b;
            });
            var b = a.slice(1);
            a = a.join(', ') + ((j < f.bytecode.length) ? ',' : '');
            b = bc.name + ( b.length ? ( '(' + b.join(',') + ')' ) : '' );
            console.log('      ' + a + '\t// ' + b);
        }
        console.log('    ]');
        console.log('  });');
    });
    console.log('');
    console.log('  // literals');
    bc.literals.forEach(function(lv, i) {
        var str;
        if (typeof(lv) === "number" ) {
            str = lv.toString() + 'f64';
            if (isNaN(lv)) { str = 'f64::NaN'; }
            if (!isFinite(lv)) { str = 'f64::infinity'; }
            str = "JsNumber(" + str + ")";
        } else if (typeof(lv) === "string") {
            str = "JsVal::from_str(" + rust_esc(lv) + ")";
        } else if (typeof(lv) === "boolean") {
            str = "JsBool(" + (lv ? "true" : "false") + ")";
        } else if (lv === null) {
            str = "JsNull";
        } else if (lv === undefined) {
            str = "JsUndefined";
        } else {
            console.assert(false);
        }
        console.log('  vec::push(literals, '+str+');\t// '+i);
    });
    console.log('}');
    // XXX for a static array, we could also do:
    //   static functions : &'static[Function] = &[];

    //console.log(bc);
});
