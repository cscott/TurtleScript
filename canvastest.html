<!DOCTYPE html>
<html>
<head>
<title>Canvas events test</title>
<meta name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black" />
<link rel="shortcut icon" href="images/turtle_icon-16x16.ico" />
<link rel="apple-touch-icon" href="images/turtle_icon-128x128.png" />
<link rel="apple-touch-startup-image" href="images/turtle_splash-320x460.png" />
<!-- XXX apparently alternate size startup images don't work yet on  iOS XXX
     XXX only solution is to use document.write() to add an appropriate
     XXX link element on the fly, boo.  And even that doesn't work for the
     XXX retina display resolution. -->
<!--
<link rel="apple-touch-startup-image"
      sizes="640x920" href="images/turtle_splash-640x920.png" />
<link rel="apple-touch-startup-image"
      sizes="1024x748" href="images/turtle_splash-1024x748.png" />
<link rel="apple-touch-startup-image"
      sizes="768x1004" href="images/turtle_splash-768x1004.png" />
-->
<style type="text/css">
html, body, canvas { padding: 0; margin: 0; }
#canvas {
  position: absolute;
  width: 100%; height: 100%;
  -webkit-user-select: none;
}
</style>
<script type="text/javascript" src="global.js"></script>
<script type="text/javascript" src="extensions.js"></script>
<script type="text/javascript" src="ccanvas.js"></script>
<script type="text/javascript" src="events.js"></script>
<script type="text/javascript">
var canvas;
var canvasElem;
var flapjax;

var USE_FRAME_TIMER = false;

var drawFrame = function(touchB, tickB) {
  var lastTouches = touchB.valueNow();
  var sz = canvas.size();

  canvas.resize(window.innerWidth, window.innerHeight,
                window.devicePixelRatio || 1);
  canvas.clearRect(0,0,sz.width, sz.height);

  canvas.setFontHeight(20);
  // XXX window.orientation is not reliable; the resize callback seems to occur
  //     before window.orientation changes.  Just looking at the width/height
  //     is probably better.
  var orientation = (canvas.size().width > canvas.size().height) ?
      "landscape" : "portrait";
  var str = "Width: "+canvas.size().width+", "+
            "Height: "+canvas.size().height+", "+
            "O: "+orientation;
  // work around iOS bug which clips text unless something *else*
  // ensures that the invalidation rectangle is big enough.
  var m = canvas.measureText(str);
  canvas.setFill(canvas.makeColor(255,255,255));
  canvas.beginPath();
  canvas.rect(0.5, 0.5, 0.5+m.width, 0.5+m.height);
  canvas.fill();

  canvas.setFill(canvas.makeColor(0,0,0));
  canvas.drawText(str, 0.5, 0.5+2*m.height);
  canvas.drawText("Touches: "+lastTouches.length, 0.5, 0.5+3*m.height);

  var amt = (tickB.valueNow() % sz.width) / sz.width; // 0-1
  canvas.setFill(canvas.makeColor(Math.floor(amt*255),0,0));
  canvas.beginPath();
  canvas.rect(amt*sz.width, 0, 10, 50);
  canvas.fill();

  // draw a mark at every point
  canvas.beginPath();
  var size=50;
  var i = 0;
  while (i < lastTouches.length) {
    /*
    canvas.setFill(canvas.makeColor(Math.floor(amt*255),
                                    Math.floor(lastTouches[i].force*255),
                                    0));
    */
    canvas.rect(lastTouches[i].clientX-size,
                lastTouches[i].clientY-size,
                size*2, size*2);
    i+=1;
  }
  canvas.fill();
};
if (window.navigator.userAgent.indexOf('iPhone') != -1) {
  if (!window.navigator.standalone == true) {
    // XXX display message prompting to add this app to the home screen
  }
}

window.onload=function() {
  canvas = make_canvas('canvas');
  canvasElem = document.getElementById('canvas');

  // set up event loop
  flapjax = make_flapjax(window.setTimeout, window.clearTimeout);
  uiEvents = flapjax.receiverE(); // new empty event stream
  // frame timer (optional)
  if (USE_FRAME_TIMER) {
    var FrameTickEvent = function() {
      this.type = "frametick";
      this.tick = (FrameTickEvent.lastTick || 0) + 1;
      FrameTickEvent.lastTick = this.tick;
    };
    window.setInterval(function() {
      uiEvents.sendEvent(new FrameTickEvent());
    }, 30);
  }
  // pass on touchstart/touchmove/touchcancel events
  var sender = function(e) { e.preventDefault(); uiEvents.sendEvent(e); };
  canvasElem.addEventListener('touchstart', sender, false);
  canvasElem.addEventListener('touchmove', sender, false);
  canvasElem.addEventListener('touchend', sender, false);
  canvasElem.addEventListener('touchcancel', sender, false);

  // emulate touches with mouse events for desktop platforms.
  var onMouseMove = function(e) {
    uiEvents.sendEvent({
      type: "touchmove",
      emulated: true,
      targetTouches: [ { clientX: e.clientX, clientY: e.clientY } ]
    });
  };
  var onMouseUp = function(e) {
    uiEvents.sendEvent({
      type: "touchend",
      emulated: true,
      targetTouches: []
    });
    canvasElem.removeEventListener('mousemove', onMouseMove, false);
    canvasElem.removeEventListener('mouseup', onMouseUp, false);
  };
  var onMouseDown = function(e) {
    uiEvents.sendEvent({
      type: "touchstart",
      emulated: true,
      targetTouches: [ { clientX: e.clientX, clientY: e.clientY } ]
    });
    canvasElem.addEventListener('mousemove', onMouseMove, false);
    canvasElem.addEventListener('mouseup', onMouseUp, false);
  };
  canvasElem.addEventListener('mousedown', onMouseDown, false);

  // notify on resize events
  window.onresize = function() {
    uiEvents.sendEvent({ type: "resize" });
  };

  // helper function
  var filterByType = function(evt, type) {
    var ty = type.toLowerCase();
    return evt.filterE(function(e) { return e.type.toLowerCase()===ty; });
  };

  // behaviors, filtered from the master event stream.
  var tickB = filterByType(uiEvents, "frametick").
              mapE(function(e) { return e.tick }).startsWith(0);
  var touchE = uiEvents.filterE(function(e) {
    var ty = e.type.toLowerCase();
    if (ty==="touchstart") { return e.targetTouches.length===1; }
    if (ty==="touchmove" || ty==="touchcancel") { return true; }
    if (ty==="touchend") { return e.targetTouches.length === 0; }
    return false;
  }).mapE(function(e) { return e.targetTouches; });

  /* this appears unnecessary: */
  touchE = touchE.filterRepeatsE(
    undefined, function eq(x, y) {
    // test two 'target touches' arrays for equality
    if (x.length !== y.length) { return false; }
    for (var i=0; i<x.length; i++) {
      if (x[i].clientX !== y[i].clientX) { return false; }
      if (x[i].clientY !== y[i].clientY) { return false; }
    }
    return true;
  }, function clone(x) {
    var r = [];
    Array.prototype.forEach.call(x, function(e) {
      r.push({ clientX: e.clientX, clientY: e.clientY });
    });
    return r;
  });

  var touchB = touchE.startsWith([]);

  var resizeE = filterByType(uiEvents, "resize");

  var drawFrameE = resizeE;
  if (USE_FRAME_TIMER) {
    // draw new frames based on the tick counter.
    drawFrameE = drawFrameE.mergeE(tickB.changes());
  } else {
    // alternatively, map target touches to drawn frames.
    drawFrameE = drawFrameE.mergeE(touchB.changes());
  }
  // don't try to draw frames faster than the eye can see
  drawFrameE = drawFrameE.calmE(35);
  // draw frames in the future
  drawFrameE.mapE(function(_) { drawFrame(touchB, tickB); });
  // draw first frame right now.
  drawFrame(touchB, tickB);
};
</script>
</head>
<body><canvas id="canvas"></canvas></body>
</html>
